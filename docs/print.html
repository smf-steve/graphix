<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Graphix Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro-to-graphix"><a class="header" href="#intro-to-graphix">Intro to Graphix</a></h1>
<p>Graphix is a programming language using the dataflow paradigm. It is
particularly well suited to building user interfaces, and interacting
with resources in
<a href="https://netidx.github.io/netidx-book">netidx</a>. Dataflow languages
like Graphix are "reactive", like React or Vue, except at the language
level instead of just as a library. A Graphix program is compiled to a
directed graph, operations (such as +) are graph nodes, edges
represent paths data can take through the program. A simple expression like,</p>
<pre><code class="language-graphix">2 + 2
</code></pre>
<p>will compile to a graph like</p>
<pre><code>         
const(2) ──&gt; + &lt;── const(2)
         
</code></pre>
<p>The semantics of simple examples like this aren't noticibly different
from a normal programming language. However a more complex example
such as,</p>
<pre><code class="language-graphix">let x = cast&lt;i64&gt;(net::subscribe("/foo")?)?;
print(x * 10)
</code></pre>
<p>compiles to a graph like</p>
<pre><code>                                               const(10)
                                                   │
                                                   │
                                                   ▼
                                         
const("/foo") ──&gt; net::subscribe ──&gt; cast&lt;i64&gt; ──&gt; * ──&gt; print
                                         
</code></pre>
<p>Unlike the first example, the value of <code>net::subscribe</code> isn't a
constant, it can change if the value published in netidx changes. If
that happens the new value will flow through the graph and will be
printed again. If the published value of "/foo" is initially 10, and
then the value of "/foo" changes to 5 then the program will print.</p>
<pre><code>100
50
</code></pre>
<p>It will keep running forever, if "/foo" changes again, it will print
more output. This is a powerful way to think about programming, and
it's especially well suited to building user interfaces and
transforming data streams.</p>
<h2 id="dataflow-but-otherwise-normal"><a class="header" href="#dataflow-but-otherwise-normal">Dataflow but Otherwise Normal</a></h2>
<p>Besides being a dataflow language Graphix tries hard to be a normal
functional language that would feel familiar to anyone who knows
Haskell, OCaml, F# or a similar ML derived language. Some of it's
features are,</p>
<ul>
<li>lexically scoped</li>
<li>expression oriented</li>
<li>strongly statically typed</li>
<li>type inference</li>
<li>structural type discipline</li>
<li>parametric polymorphism</li>
<li>algebraic data types</li>
<li>pattern matching</li>
<li>first class functions, and closures</li>
<li>late binding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-graphix"><a class="header" href="#installing-graphix">Installing Graphix</a></h1>
<p>To install the Graphix shell from source you need to install a rust build
environment. See <a href="https://www.rust-lang.org/tools/install">here</a> for
instructions on how to do that for your platform. Once you have that set up, you
can just run</p>
<p><code>cargo install graphix-shell</code></p>
<p>That should build the <code>graphix</code> command and install it in your
~/.cargo/bin directory. Windows and Mac OS should work out of the box
as long as you have the prerequisites for rust installed.</p>
<h2 id="linux-prerequisites"><a class="header" href="#linux-prerequisites">Linux Prerequisites</a></h2>
<h3 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h3>
<p>You need to install</p>
<ul>
<li>clang</li>
<li>libkrb5-dev</li>
</ul>
<h3 id="on-fedora"><a class="header" href="#on-fedora">On Fedora</a></h3>
<p>You need to install</p>
<ul>
<li>clang-devel</li>
<li>krb5-devel</li>
</ul>
<h2 id="netidx"><a class="header" href="#netidx">Netidx</a></h2>
<p>Graphix uses netidx to import and export data streams. So it is
recommended that you set up at least a machine local installation of
netidx when installing Graphix. Otherwise separate Graphix processes
won't be able to communicate with each other and it will be difficult
to get any data into Graphix.</p>
<p>See <a href="https://netidx.github.io/netidx-book">here</a> for details</p>
<p>If you don't want to set up netidx Graphix will still work, it just
won't be able to use the net module to send anything outside the
current process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Welcome to Graphix! This tutorial will get you up and running in about 10-15 minutes. You'll learn how to use the interactive REPL, write your first expressions, and create a simple reactive program.</p>
<p>By the end of this guide, you'll understand the basics of Graphix's reactive dataflow model and be ready to explore the language in depth.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Make sure you've already <a href="./install.html">installed Graphix</a>. You can verify your installation by running:</p>
<pre><code class="language-bash">graphix --version
</code></pre>
<h2 id="starting-the-repl"><a class="header" href="#starting-the-repl">Starting the REPL</a></h2>
<p>The Graphix shell provides an interactive Read-Eval-Print Loop (REPL) where you can experiment with the language. Start it by running <code>graphix</code> with no arguments:</p>
<pre><code class="language-bash">graphix
</code></pre>
<p>You'll see a prompt that looks like this:</p>
<pre><code>Welcome to the graphix shell
Press ctrl-c to cancel, ctrl-d to exit, and tab for help
〉
</code></pre>
<p>The REPL evaluates expressions and shows you both the type and the value. The output format is:</p>
<pre><code>-: Type
value
</code></pre>
<p>Let's try it!</p>
<h2 id="your-first-expressions"><a class="header" href="#your-first-expressions">Your First Expressions</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>Type some simple arithmetic at the prompt:</p>
<pre><code class="language-graphix">〉2 + 2
-: i64
4
</code></pre>
<p>The <code>-: i64</code> line tells you the result is a 64-bit integer, and <code>4</code> is
the value. You may be wondering why you don't get the 〉 prompt after
running this expression. This is because, being a dataflow language,
expressions are pipelines that can output more than one value, they
will run until you stop them by hitting ctrl-c. Do this now to get the
prompt back.</p>
<p>Since ctrl-c is used to stop the currently running pipeline, if you
want to exit the REPL press ctrl-d.</p>
<p>Try a more complex expression:</p>
<pre><code class="language-graphix">〉10 * 5 + 3
-: i64
53
〉2.5 * 4.0
-: f64
10.0
</code></pre>
<p>Notice that integer arithmetic produces <code>i64</code> (integer) results, while floating-point arithmetic produces <code>f64</code> (float) results.</p>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings are written in double quotes:</p>
<pre><code class="language-graphix">〉"Hello, Graphix!"
-: string
"Hello, Graphix!"
</code></pre>
<h3 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h3>
<p>Graphix supports string interpolation using square brackets. Any expression inside <code>[...]</code> in a string will be evaluated and inserted:</p>
<pre><code class="language-graphix">〉"The answer is [2 + 2]"
-: string
"The answer is 4"
〉"2 + 2 = [2 + 2], and 10 * 5 = [10 * 5]"
-: string
"2 + 2 = 4, and 10 * 5 = 50"
</code></pre>
<p>This is incredibly useful for building dynamic strings!</p>
<h2 id="variables-with-let-binds"><a class="header" href="#variables-with-let-binds">Variables with Let Binds</a></h2>
<p>Use <code>let</code> to create named bindings:</p>
<pre><code class="language-graphix">〉let x = 42
〉x
-: i64
42
〉let name = "World"
〉"Hello, [name]!"
-: string
"Hello, World!"
</code></pre>
<p>You can reuse the same name to create a new binding (this is called shadowing):</p>
<pre><code class="language-graphix">〉let x = 10
〉let x = x + 5
〉x
-: i64
15
</code></pre>
<p>The second <code>let x</code> creates a new binding that references the previous value of <code>x</code>.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions in Graphix are first-class values. Create them with the lambda syntax <code>|args| body</code>:</p>
<pre><code class="language-graphix">〉let double = |x| x * 2
〉double(21)
-: i64
42
</code></pre>
<p>You can add type annotations if you want to be explicit:</p>
<pre><code class="language-graphix">〉let add = |x: i64, y: i64| x + y
〉add(10, 32)
-: i64
42
</code></pre>
<p>Functions can capture variables from their surrounding scope:</p>
<pre><code class="language-graphix">〉let multiplier = 3
〉let times_three = |x| x * multiplier
〉times_three(14)
-: i64
42
</code></pre>
<h2 id="creating-your-first-file"><a class="header" href="#creating-your-first-file">Creating Your First File</a></h2>
<p>Now let's write a real Graphix program! Create a file called <code>hello.gx</code> with this content:</p>
<pre><code class="language-graphix">use tui;
use tui::text;

let count = 0;
let timer = time::timer(duration:1.s, true);
count &lt;- timer ~ (count + 1);

text(&amp;"Count: [count]")
</code></pre>
<p>This program demonstrates Graphix's reactive nature:</p>
<ul>
<li>We start with <code>count = 0</code></li>
<li><code>time::timer(duration:1.s, true)</code> creates a timer that fires every second</li>
<li>The <code>~</code> operator samples the right side when the left side updates</li>
<li><code>count &lt;- ...</code> schedules an update to <code>count</code> for the next cycle</li>
<li>Every second, <code>count</code> increments and the text automatically updates</li>
<li>The last expression creates a text widget displaying the count</li>
</ul>
<h2 id="running-your-file"><a class="header" href="#running-your-file">Running Your File</a></h2>
<p>Run your program with:</p>
<pre><code class="language-bash">graphix hello.gx
</code></pre>
<p>You'll see a terminal UI that displays the count increasing every second! The screen updates automatically because Graphix tracks dependencies and propagates changes through the dataflow graph.</p>
<p>To stop the program, press <code>Ctrl+C</code>.</p>
<h2 id="a-simpler-example"><a class="header" href="#a-simpler-example">A Simpler Example</a></h2>
<p>If you want to see the reactive behavior without the TUI, try this simpler version (<code>counter.gx</code>):</p>
<pre><code class="language-graphix">let count = 0;
let timer = time::timer(duration:1.s, true);
count &lt;- timer ~ (count + 1);
"Count: [count]"
</code></pre>
<p>Run it with <code>graphix counter.gx</code> and you'll see the count printed to the console every second.</p>
<h2 id="understanding-the-output"><a class="header" href="#understanding-the-output">Understanding the Output</a></h2>
<p>In Graphix programs:</p>
<ul>
<li><strong>The last value</strong> is what determines what the shell displays
<ul>
<li>If it's a <code>Widget</code> type (like our text example), then it is rendered as a TUI</li>
<li>Otherwise, the value is printed to the console every time it updates</li>
</ul>
</li>
<li><strong>Use <code>print</code> or <code>println</code></strong> for explicit output during execution</li>
<li><strong>Programs run forever</strong> unless they explicitly exit - they're reactive graphs that respond to events</li>
</ul>
<h3 id="the-dataflow-model"><a class="header" href="#the-dataflow-model">The Dataflow Model</a></h3>
<p>The key insight: when <code>timer</code> updates, it triggers an update to <code>count</code> (via the <code>&lt;-</code> connect operator), which triggers an update to the text widget. The entire chain reacts automatically. You describe <em>what</em> should happen, not <em>when</em> or <em>how</em> to update things.</p>
<p>This is very different from traditional imperative programming where you'd need loops and manual state management. In Graphix, you build a graph of dependencies and the runtime handles updates for you.</p>
<h2 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h2>
<p>Experiment with these ideas:</p>
<ol>
<li>Modify the counter to count down instead of up</li>
<li>Make it count by 2s or 10s instead of 1s</li>
<li>Change the timer interval to 0.5 seconds</li>
<li>Display multiple values that update independently</li>
<li>Try arithmetic on the count (show doubled value, squared value, etc.)</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you've experienced Graphix's reactive nature, you're ready to dive deeper:</p>
<ul>
<li><strong><a href="./core/overview.html">Core Language</a></strong> - Learn the fundamental language constructs</li>
<li><strong><a href="./functions/overview.html">Functions</a></strong> - Master functions, closures, and higher-order programming</li>
<li><strong><a href="./ui/overview.html">Building UIs</a></strong> - Create rich terminal user interfaces</li>
<li><strong><a href="./stdlib/overview.html">Standard Library</a></strong> - Explore built-in functions and modules</li>
</ul>
<p>The best way to learn Graphix is to experiment! Keep the REPL open as you read through the documentation and try out the examples. Every code snippet in this book is designed to be runnable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-language"><a class="header" href="#core-language">Core Language</a></h1>
<p>This chapter introduces the core constructs that make Graphix work. If you're coming from imperative languages like Python, Java, or C, some of these concepts will feel familiar—but the reactive twist makes them work differently than you might expect.</p>
<h2 id="types-strong-but-flexible"><a class="header" href="#types-strong-but-flexible">Types: Strong but Flexible</a></h2>
<p>Graphix has a powerful static type system, but you'll rarely write type annotations. The compiler infers types for you using structural typing—types are compared by their shape, not their name. A struct <code>{x: i64, y: i64}</code> is the same type whether you call it <code>Point</code> or <code>Vector</code> or don't name it at all.</p>
<p>The <strong><a href="core/./fundamental_types.html">Fundamental Types</a></strong> section covers the built-in numeric types (<code>i64</code>, <code>f64</code>, <code>u32</code>, etc.), booleans, strings, durations, and more. You'll learn how arithmetic works across different numeric types, how string interpolation works with <code>[...]</code> brackets, and why division by zero doesn't crash your program.</p>
<p><strong><a href="core/./reading_types.html">Reading Type Signatures</a></strong> teaches you how to read the type annotations you'll see throughout the documentation. Function types like <code>fn(Array&lt;'a&gt;, fn('a) -&gt; 'b) -&gt; Array&lt;'b&gt;</code> tell you exactly what a function expects and returns, including what errors it might throw.</p>
<h2 id="binding-values-and-building-blocks"><a class="header" href="#binding-values-and-building-blocks">Binding Values and Building Blocks</a></h2>
<p>In Graphix, you create bindings with <code>let</code>. Unlike variables in other languages, these bindings can update over time—they're more like pipes that different values flow through.</p>
<p><strong><a href="core/./let_binds.html">Let Binds</a></strong> explains how to create bindings, how shadowing works, and why every binding in Graphix is potentially reactive. When you write <code>let x = 42</code>, you're not just storing a value—you're creating a node in the dataflow graph.</p>
<p><strong><a href="core/./block.html">Blocks</a></strong> shows how to group expressions with <code>{...}</code> to create scopes, hide intermediate bindings, and build up complex expressions. Blocks are expressions too—they evaluate to their last value.</p>
<p><strong><a href="core/./use.html">Use</a></strong> lets you bring module names into scope so you can write <code>map(arr, f)</code> instead of <code>array::map(arr, f)</code>. Simple, but essential as your programs grow.</p>
<h2 id="connect-the-heart-of-reactivity"><a class="header" href="#connect-the-heart-of-reactivity">Connect: The Heart of Reactivity</a></h2>
<p>This is where Graphix becomes special. The <code>&lt;-</code> operator (connect) is the only way to create cycles in your dataflow graph, and it's the key to writing reactive programs and loops.</p>
<p><strong><a href="core/./connect.html">Connect</a></strong> is the most important section in this chapter. When you write:</p>
<pre><code class="language-graphix">let count = 0;
count &lt;- timer ~ (count + 1)
</code></pre>
<p>You're telling Graphix: "When <code>timer</code> updates, increment <code>count</code> for the next cycle." Connect schedules updates for the future, which is how you build everything from simple counters to complex state machines. It's also the only looping construct in Graphix—there's no <code>for</code> or <code>while</code>, just connect and select working together.</p>
<h2 id="select-pattern-matching-with-power"><a class="header" href="#select-pattern-matching-with-power">Select: Pattern Matching with Power</a></h2>
<p>The <code>select</code> expression is Graphix's answer to <code>switch</code>, <code>match</code>, and <code>if/else</code>—but much more powerful. It lets you match on types, destructure complex data, and ensure at compile time that you've handled every case.</p>
<p><strong><a href="core/./select.html">Select</a></strong> shows you how to:</p>
<ul>
<li>Match on union types and ensure you handle all variants</li>
<li>Destructure arrays with slice patterns like <code>[head, tail..]</code></li>
<li>Match structs with patterns like <code>{x, y}</code></li>
<li>Guard patterns with conditions like <code>n if n &gt; 10</code></li>
<li>Build loops by combining select with connect</li>
</ul>
<p>The compiler checks your select expressions exhaustively—if you forget a case, it won't compile. If you match a case that can never happen, it won't compile. This eliminates entire classes of bugs.</p>
<h2 id="error-handling-exceptions-done-right"><a class="header" href="#error-handling-exceptions-done-right">Error Handling: Exceptions, Done Right</a></h2>
<p>Graphix has first-class error handling with try/catch and the <code>?</code> operator. Errors are just values with the special <code>Error&lt;'a&gt;</code> type, and they're tracked through the type system.</p>
<p><strong><a href="core/./error.html">Error Handling</a></strong> explains:</p>
<ul>
<li>How <code>?</code> throws errors to the nearest try/catch in dynamic scope</li>
<li>How error types are checked at compile time—you can't forget to handle an error type</li>
<li>How the <code>$</code> operator silently swallows errors (use with caution!)</li>
<li>How error chains track the full context of where errors originated</li>
</ul>
<p>Every error that gets raised with <code>?</code> is wrapped in an <code>ErrChain</code> that captures the file, line, column, and full stack of previous errors. No more mystery exceptions.</p>
<h2 id="how-it-all-fits-together"><a class="header" href="#how-it-all-fits-together">How It All Fits Together</a></h2>
<p>These constructs combine to create the Graphix programming model:</p>
<ol>
<li>You create <strong>bindings</strong> that hold values</li>
<li>You build <strong>expressions</strong> that compute new values from old ones</li>
<li>You use <strong>select</strong> to handle different cases and make decisions</li>
<li>You use <strong>connect</strong> to update bindings when events occur</li>
<li>The <strong>type system</strong> ensures everything is safe and correct</li>
<li><strong>Errors</strong> propagate cleanly through try/catch</li>
</ol>
<p>The result is a language where you describe relationships between values, and the runtime automatically maintains those relationships as things change. A temperature value updates, and the Fahrenheit conversion updates automatically. A timer fires, and your counter increments. A network subscription delivers new data, and your UI reflects it instantly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-types"><a class="header" href="#fundamental-types">Fundamental Types</a></h1>
<p>Graphix has a few fundamental data types, the Graphix shell is a good way to
explore them by trying out small Graphix expressions. You can run the Graphix
shell by invoking <code>graphix</code> with no arguments.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p><code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f32</code>, <code>f64</code>, and <code>decimal</code> are the fundamental
numeric types in Graphix. Literals are written with their type prefixed, except
for <code>i64</code> and <code>f64</code> which are written bare. for example, <code>u32:3</code> is a <code>u32</code>
literal value.</p>
<p><code>decimal</code> is an exact decimal representation for performing financial
calculations without rounding or floating point approximation errors.</p>
<p>The basic arithmetic operations are implemented on all the number types with all
the other number types.</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Operator</th></tr></thead><tbody>
<tr><td>Add</td><td>+</td></tr>
<tr><td>Subtract</td><td>-</td></tr>
<tr><td>Multiply</td><td>*</td></tr>
<tr><td>Divide</td><td>/</td></tr>
<tr><td>Mod</td><td>%</td></tr>
</tbody></table>
</div>
<p>The compiler will let you do arithmetic on different types of numbers directly
without casting, however the return type of the operation will be the set of all
the types in the operation, representing that either type could be returned. If
you try to pass this result to a function that wants a specific numeric type, it
will fail at compile time.</p>
<pre><code class="language-graphix">〉1. + 1
-: [i64, f64]
2
〉let f = |x: i64| x * 10
〉f(1. + 1)
error: in expr

Caused by:
    0: at: line: 1, column: 3, in: (f64:1. + i64:1)
    1: at: line: 1, column: 3, in: (f64:1. + i64:1)
    2: type mismatch '_1046: i64 does not contain [i64, f64]
</code></pre>
<p>Division by zero is raised as an error to the nearest error handler (more on
that later) and will be printed to stderr by the shell if it is never handled.
Overflow and underflow are handled by wrapping,</p>
<pre><code class="language-graphix">〉0 / 0

thread 'tokio-runtime-worker' panicked at &lt;rust runtime&gt;:
attempt to divide by zero
-: i64
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
unhandled error: error:"in expr at line: 1, column: 1 attempt to divide by zero"
〉u32:0 - u32:1
-: u32
4294967295
</code></pre>
<p>The thread panic message is an artifact of how the overflow error is handled at
runtime, it is safe to continue using the shell and runtime if such an error
occurs. However the particular arith operation that caused the error will not
update, which may cause problems depending on what your program is doing with
it.</p>
<h4 id="v32-z32-v64-z64"><a class="header" href="#v32-z32-v64-z64">v32, z32, v64, z64</a></h4>
<p>These number types are the same as the normal types except when they
are sent over the wire via netidx (or written to a file) they use
variable width encoding instead of normal encoding. The number of
bytes used varies for 64 bit numbers to between 1 and 10. Small
numbers (below 127) are encoded in 1 byte, larger number use more
bytes. The type correspondence is,</p>
<div class="table-wrapper"><table><thead><tr><th>Compact</th><th>Normal</th></tr></thead><tbody>
<tr><td>v32</td><td>u32</td></tr>
<tr><td>z32</td><td>i32</td></tr>
<tr><td>v64</td><td>u64</td></tr>
<tr><td>z64</td><td>i64</td></tr>
</tbody></table>
</div>
<h3 id="number-sets"><a class="header" href="#number-sets">Number Sets</a></h3>
<p>There are a few sets of number types that classify numbers into various kinds.
<code>Number</code> being the most broad, it contains all the number types. <code>Int</code> contains
only integers, <code>Real</code> contains only reals (decimal plus the two float types),
<code>SInt</code> contains signed integers, <code>UInt</code> contains unsigned integers.</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>Boolean literals are written as <code>true</code> and <code>false</code>, and the name of the boolean
type is <code>bool</code>.</p>
<p>Boolean expressions using <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are supported. These operators
only operate on <code>bool</code>. They can be grouped with parenthesis. For example,</p>
<pre><code class="language-graphix">〉true &amp;&amp; false
-: bool
false
〉true || false
-: bool
true
〉!true
-: bool
false
〉!1
error: in expr

Caused by:
    0: at: line: 1, column: 2, in: i64:1
    1: type mismatch bool does not contain i64
</code></pre>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>A time duration. The type name is <code>duration</code>, and the literals are written as,
<code>duration:1.0s</code>, <code>duration:1.0ms</code>, <code>duration:1.0us</code>, <code>duration:1.0ns</code>. Durations
can be added, and can be multiplied and divided by scalars.</p>
<pre><code class="language-graphix">〉duration:1.0s + duration:1.0s
-: duration
2.s
〉duration:1.0s * 50
-: duration
50.s
〉duration:1.0s / 50
-: duration
0.02s
</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>A date and time in the UTC time zone. The type name is <code>datetime</code> and literals
are written in RFC3339 format inside quotes. For example,
<code>datetime:"2020-01-01T00:00:00Z"</code>. You can add and subtract <code>duration</code> from
<code>datetime</code>.</p>
<pre><code class="language-graphix">〉datetime:"2020-01-01T00:00:00Z" + duration:30.s
-: datetime
2020-01-01 00:00:30 UTC
</code></pre>
<p>You can enter <code>datetime</code> literals in local time and they will be converted to UTC. For example,</p>
<pre><code class="language-graphix">〉datetime:"2020-01-01T00:00:00-04:00"
-: datetime
2020-01-01 04:00:00 UTC
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Strings in Graphix are UTF8 encoded text. The type name is <code>string</code> and the
literal is written in quotes <code>"this is a string"</code>. C style escape sequences are
supported, <code>"this is \" a string with a quote and a \n"</code>. Non printable
characters such as newline will be escaped by default when strings are printed
to the console, you can use <code>print</code> to print the raw string including control
characters.</p>
<h3 id="string-interpolation-1"><a class="header" href="#string-interpolation-1">String Interpolation</a></h3>
<p>String literals can contain expressions that will be evaluated and joined to the string,
such expressions are surrounded by unescaped <code>[]</code> in the string. For example,</p>
<pre><code class="language-graphix">〉let row = 1
〉let column = 999
〉"/foo/bar/[row]/[column]"
-: string
"/foo/bar/1/999"
</code></pre>
<p>Values in an interpolation need not be strings, they will be cast to a string
when they are used. You can write a literal <code>[</code> or <code>]</code> in a string by escaping
it.</p>
<pre><code class="language-graphix">〉"this is a string with a \[ and a \] but it isn't an interpolation"
-: string
"this is a string with a [ and a ] but it isn't an interpolation"
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>The <code>Any</code> type is a type that unifies with any other type, it corresponds to the
underlying variant type that represents all values in Graphix (and netidx). It
is not used very often, as it provides very few guarantees, however it has it's
place. For example, <code>Any</code> is the type returned by <code>net::subscribe</code>, indicating
that any valid netidx value can come from the network. Usually the first thing
you do with an <code>Any</code> type is call <code>cast</code> to turn it into the type you expect (or
an error), or use a <code>select</code> expression to match it's type (more on select later).</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>Null is nothing, just like in many other languages. Unlike most other languages
<code>null</code> is a type not a catch all. If the type of a value does not include <code>null</code>
then it can't be null. The set <code>['a, null]</code> (alias <code>Option&lt;'a&gt;</code>) is commonly
used to represent things that will sometimes return <code>null</code>.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Arrays are immutable, contiguous, and homogeneous. They are
parameterized, <code>Array&lt;string&gt;</code> indicates an array of strings. Arrays
are zero indexed <code>a[0]</code> is the first element. Array elements can be
any type, including other arrays at arbitrary levels of nesting. There
is a special <code>array</code> type that acts like <code>Array&lt;Any&gt;</code>, that represents
the fundamental array type in the underlying value representation.
Array literals are written like <code>[x, y, z]</code>. There are many functions
in the <code>array</code> module of the standard library for working with arrays.</p>
<h3 id="array-slicing-and-indexing"><a class="header" href="#array-slicing-and-indexing">Array Slicing and Indexing</a></h3>
<p>Graphix supports array subslicing, the syntax will be familiar to Rust programmers.</p>
<ul>
<li><code>a[2..]</code> a slice from index 2 to the end of the array</li>
<li><code>a[..4]</code> a slice from the beginning of the array to index 3</li>
<li><code>a[1..3]</code> a slice from index 1 to index 2</li>
<li><code>a[-1]</code> the last element in the array</li>
<li><code>a[-2]</code> the second to last element in the array</li>
</ul>
<p><code>..=</code> is not supported however, the second part of the slice will always be the
exclusive bound. Literal numbers can always be replaced with a Graphix
expression, e.g. <code>a[i..j]</code> is perfectly valid.</p>
<h3 id="mutability-and-implementation"><a class="header" href="#mutability-and-implementation">Mutability and Implementation</a></h3>
<p>Arrays are not mutable, like all other Graphix values. All operations that
"change" an array, actually create a new array leaving the old one unchanged.
This is even true of the connect operator, which we will talk more about later.</p>
<p>There are a couple of important notes to understand about the implementation of
Arrays.</p>
<ul>
<li>
<p>Arrays are memory pooled, in almost all cases (besides really huge arrays)
creating an array does not actually allocate any memory, it just reuses a
previously used array that has since become unused. This makes using arrays a
lot more efficient than you might expect.</p>
</li>
<li>
<p>Arrays are contiguous in memory. This means they are generally very
memory efficient, each element is 2 machine words, and O(1) to
access. However there are a few cases where this causes a problem,
such as building up an array by appending one element at a
time. This is sadly an O(n^2) operation on arrays. You may wish to
use another data structure, such as a map (which would be O(n
log(n)) if you need to build a large data structure this way.</p>
</li>
<li>
<p>Array slices are zero copy, and also pooled. They simply create a
light weight view into the array. This means algorithms that
progressively deconstruct an array by slicing are O(N) not O(N^2)
and the constants are very fast.</p>
</li>
</ul>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are written <code>(x, y)</code>, they can be of arbitrary length, and each element
may have a different type. Tuples may be indexed using numeric field indexes.
Consider</p>
<pre><code class="language-graphix">let x = (1, 2, 3, 4);
x.0
</code></pre>
<p>Will print 1.</p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>Maps in Graphix are key-value data structures with O(log(N)) lookup, insert, and
remove operations. Maps are parameterized by their key and value type, for
example <code>Map&lt;string, i64&gt;</code> indicates a map with string keys and integer values.
There are many functions for working with maps in the <code>map</code> standard library
module</p>
<h3 id="map-literals"><a class="header" href="#map-literals">Map Literals</a></h3>
<p>Maps can be constructed using the <code>{key =&gt; value}</code> syntax:</p>
<pre><code class="language-graphix">〉{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
-: Map&lt;'_1893: string, '_1895: i64&gt;
{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
</code></pre>
<p>Keys and values can be any Graphix type, for example here is a map where the key
is a <code>Map&lt;string, i64&gt;</code>.</p>
<pre><code class="language-graphix">{{"foo" =&gt; 42} =&gt; "foo", {"bar" =&gt; 42} =&gt; "bar"}
-: Map&lt;'_1919: Map&lt;'_1915: string, '_1917: i64&gt;, '_1921: string&gt;
{{"bar" =&gt; 42} =&gt; "bar", {"foo" =&gt; 42} =&gt; "foo"}
</code></pre>
<h3 id="map-indexing"><a class="header" href="#map-indexing">Map Indexing</a></h3>
<p>Maps can be indexed using the <code>map{key}</code> syntax to retrieve values:</p>
<pre><code class="language-graphix">〉let m = {"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
〉m{"b"}
-: ['_1907: i64, Error&lt;`MapKeyError(string)&gt;]
2
</code></pre>
<p>If a key is not present in the map, indexing returns a <code>MapKeyError</code>:</p>
<pre><code class="language-graphix">〉m{"missing"}
-: ['_1907: i64, Error&lt;`MapKeyError(string)&gt;]
error:["MapKeyError", "map key \"missing\" not found"]
</code></pre>
<h3 id="mutability-and-implementation-1"><a class="header" href="#mutability-and-implementation-1">Mutability and Implementation</a></h3>
<p>Like all Graphix values, maps are immutable. All operations that "change" a map
actually create a new map, leaving the original unchanged. Maps are memory
pooled and very efficient - creating new maps typically reuses existing memory
rather than allocating new memory.</p>
<p>Maps maintain their key-value pairs in a balanced tree structure, ensuring
O(log(N)) performance for all operations regardless of map size.</p>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<p>Error is the built in error type. It carries a type parameter indicating the
type of error, for example <code>Error&lt;</code>MapKeyError(string)&gt;<code>is an error that carries a ``</code>MapKeyError `` variant. You can access the inner error value
using <code>e.0</code> e.g.,</p>
<pre><code class="language-graphix">〉let e = error(`MapKeyError("no such key"))
〉e.0
-: `MapKeyError(string)
`MapKeyError("no such key")
</code></pre>
<p>More information about dealing with errors is available in the section on error
handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-type-signatures"><a class="header" href="#reading-type-signatures">Reading Type Signatures</a></h1>
<p>Throughout this book and in the standard library documentation, you'll encounter function type signatures. This guide will help you understand what they mean. Don't try to memorize everything here - just use this as a reference when you encounter unfamiliar notation.</p>
<h2 id="basic-function-signatures"><a class="header" href="#basic-function-signatures">Basic Function Signatures</a></h2>
<p>The simplest function signature looks like this:</p>
<pre><code class="language-graphix">val double: fn(i64) -&gt; i64
</code></pre>
<p>This breaks down into:</p>
<ul>
<li><code>fn(...)</code> - this is a function</li>
<li><code>i64</code> - takes one parameter of type i64 (64-bit integer)</li>
<li><code>-&gt; i64</code> - returns a value of type i64</li>
</ul>
<p>Another example:</p>
<pre><code class="language-graphix">val concat: fn(string, string) -&gt; string
</code></pre>
<p>Takes two strings, returns a string.</p>
<h2 id="type-parameters-generics"><a class="header" href="#type-parameters-generics">Type Parameters (Generics)</a></h2>
<p>Type parameters (like generics in other languages) are written with a single quote followed by an identifier: <code>'a</code>, <code>'b</code>, <code>'e</code>, etc.</p>
<h3 id="simple-type-parameters"><a class="header" href="#simple-type-parameters">Simple Type Parameters</a></h3>
<pre><code class="language-graphix">val identity: fn('a) -&gt; 'a
</code></pre>
<p>This means: "takes a value of any type <code>'a</code> and returns a value of the same type <code>'a</code>". The <code>identity</code> function could work with integers, strings, or any other type.</p>
<pre><code class="language-graphix">val first: fn(Array&lt;'a&gt;) -&gt; 'a
</code></pre>
<p>This means: "takes an array of any type <code>'a</code> and returns a single element of type <code>'a</code>". If you pass an <code>Array&lt;string&gt;</code>, you get back a <code>string</code>. If you pass an <code>Array&lt;i64&gt;</code>, you get back an <code>i64</code>.</p>
<h3 id="multiple-type-parameters"><a class="header" href="#multiple-type-parameters">Multiple Type Parameters</a></h3>
<pre><code class="language-graphix">val map: fn(Array&lt;'a&gt;, fn('a) -&gt; 'b) -&gt; Array&lt;'b&gt;
</code></pre>
<p>This function takes:</p>
<ul>
<li>An array of type <code>'a</code></li>
<li>A function that transforms <code>'a</code> into <code>'b</code></li>
<li>Returns an array of type <code>'b</code></li>
</ul>
<p>The types <code>'a</code> and <code>'b</code> can be the same or different.</p>
<h2 id="optional-labeled-arguments"><a class="header" href="#optional-labeled-arguments">Optional Labeled Arguments</a></h2>
<p>Arguments prefixed with <code>?#</code> are optional and labeled:</p>
<pre><code class="language-graphix">val text: fn(?#style: Style, string) -&gt; Widget
</code></pre>
<p>This function can be called in two ways:</p>
<pre><code class="language-graphix">text("Hello")                           // style uses default value
text(#style: my_style, "Hello")        // style is specified
</code></pre>
<h3 id="order-flexibility"><a class="header" href="#order-flexibility">Order Flexibility</a></h3>
<p>Labeled arguments can be provided in any order, but must come before positional arguments:</p>
<pre><code class="language-graphix">val widget: fn(?#width: i64, ?#height: i64, string) -&gt; Widget

// All of these are valid:
widget("text")
widget(#width: 100, "text")
widget(#height: 50, #width: 100, "text")
widget(#height: 50, "text")
</code></pre>
<h2 id="required-labeled-arguments"><a class="header" href="#required-labeled-arguments">Required Labeled Arguments</a></h2>
<p>Arguments with <code>#</code> but no <code>?</code> are required but labeled:</p>
<pre><code class="language-graphix">val input_handler: fn(
    #handle: fn(Event) -&gt; Response,
    &amp;Widget
) -&gt; Widget
</code></pre>
<p>You must provide <code>#handle</code>, but it doesn't have to be in the first position. However, it must come before the unlabeled <code>&amp;Widget</code> argument:</p>
<pre><code class="language-graphix">input_handler(#handle: my_handler, &amp;my_widget)
</code></pre>
<h2 id="variadic-arguments"><a class="header" href="#variadic-arguments">Variadic Arguments</a></h2>
<p>The <code>@args</code> notation means a function accepts any number of arguments:</p>
<pre><code class="language-graphix">val sum: fn(@args: i64) -&gt; i64
</code></pre>
<p>You can call this with any number of integers:</p>
<pre><code class="language-graphix">sum(1, 2, 3)
sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
</code></pre>
<h3 id="variadic-with-required-arguments"><a class="header" href="#variadic-with-required-arguments">Variadic with Required Arguments</a></h3>
<p>Sometimes a function requires at least one argument:</p>
<pre><code class="language-graphix">val max: fn('a, @args: 'a) -&gt; 'a
</code></pre>
<p>The first <code>'a</code> is required, then any number of additional arguments of the same type.</p>
<h2 id="reference-types"><a class="header" href="#reference-types">Reference Types</a></h2>
<p>An ampersand <code>&amp;</code> before a type means "reference to" rather than the value itself:</p>
<pre><code class="language-graphix">val text: fn(&amp;string) -&gt; Widget
</code></pre>
<p>This takes a <em>reference</em> to a string, not the string value directly. References are important for:</p>
<ol>
<li><strong>Efficiency</strong> - avoid copying large data structures</li>
<li><strong>Reactivity</strong> - updating a referenced value triggers updates without rebuilding entire structures</li>
</ol>
<p>Create a reference with <code>&amp;</code> and dereference (get the value) with <code>*</code>:</p>
<pre><code class="language-graphix">let s = "Hello";
let r = &amp;s;      // r is a reference to s
let v = *r;      // v is the value "Hello"
</code></pre>
<p>In function signatures, <code>&amp;T</code> in a parameter position means the function expects a reference. In widget examples, you'll often see:</p>
<pre><code class="language-graphix">block(#title: &amp;line("My Title"), &amp;my_widget)
</code></pre>
<p>The <code>&amp;line(...)</code> creates a reference to the line, and <code>&amp;my_widget</code> is a reference to the widget.</p>
<p>For a deeper dive, see <a href="core/../udt/references.html">References</a>.</p>
<h2 id="error-types-throws"><a class="header" href="#error-types-throws">Error Types (throws)</a></h2>
<p>When a function can throw errors, the signature includes <code>throws</code>:</p>
<pre><code class="language-graphix">val divide: fn(i64, i64) -&gt; i64 throws `DivideByZero
</code></pre>
<p>This function returns <code>i64</code> if successful, but might throw a <code>DivideByZero</code> error.</p>
<h3 id="multiple-error-types"><a class="header" href="#multiple-error-types">Multiple Error Types</a></h3>
<p>A function can throw multiple error types:</p>
<pre><code class="language-graphix">val parse_and_divide: fn(string, string) -&gt; i64 throws [`ParseError, `DivideByZero]
</code></pre>
<h3 id="generic-error-types"><a class="header" href="#generic-error-types">Generic Error Types</a></h3>
<p>Often error types are parameterized:</p>
<pre><code class="language-graphix">val filter: fn('a, fn('a) -&gt; bool throws 'e) -&gt; 'a throws 'e
</code></pre>
<p>This means: the <code>filter</code> function itself doesn't throw errors, but if the function you pass to it throws errors of type <code>'e</code>, then <code>filter</code> will also throw those same errors.</p>
<h3 id="result-type"><a class="header" href="#result-type">Result Type</a></h3>
<p>The <code>Result</code> type is a convenient way to represent success or error:</p>
<pre><code class="language-graphix">type Result&lt;'r, 'e&gt; = ['r, Error&lt;'e&gt;]
</code></pre>
<p>So a function signature like:</p>
<pre><code class="language-graphix">val parse: fn(string) -&gt; Result&lt;i64, `ParseError&gt;
</code></pre>
<p>Returns either an <code>i64</code> (success) or an <code>Error&lt;</code>ParseError&gt;` (failure).</p>
<p>See <a href="core/./error.html">Error Handling</a> for complete details on working with errors.</p>
<h2 id="set-types"><a class="header" href="#set-types">Set Types</a></h2>
<p>Square brackets <code>[...]</code> denote a set type - the value can be any one of the types in the set:</p>
<pre><code class="language-graphix">val process: fn([i64, string]) -&gt; string
</code></pre>
<p>This function accepts either an <code>i64</code> or a <code>string</code>, and returns a <code>string</code>.</p>
<h3 id="optional-types-nullable"><a class="header" href="#optional-types-nullable">Optional Types (Nullable)</a></h3>
<p>The pattern <code>[T, null]</code> means "T or nothing":</p>
<pre><code class="language-graphix">val find: fn(Array&lt;string&gt;, string) -&gt; [string, null]
</code></pre>
<p>Returns a string if found, <code>null</code> if not found. This is aliased as <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-graphix">type Option&lt;'a&gt; = ['a, null]
val find: fn(Array&lt;string&gt;, string) -&gt; Option&lt;string&gt;
</code></pre>
<h3 id="nested-sets"><a class="header" href="#nested-sets">Nested Sets</a></h3>
<p>Types can nest arbitrarily:</p>
<pre><code class="language-graphix">val sum: fn(@args: [Number, Array&lt;[Number, Array&lt;Number&gt;]&gt;]) -&gt; Number
</code></pre>
<p>This accepts numbers, arrays of numbers, or even arrays of (numbers or arrays of numbers). The flexibility allows you to call:</p>
<pre><code class="language-graphix">sum(1, 2, 3)
sum([1, 2], [3, 4])
sum(1, [2, 3], 4)
</code></pre>
<h3 id="function-constraints"><a class="header" href="#function-constraints">Function Constraints</a></h3>
<p>Type variables in functions can have constraints:</p>
<pre><code class="language-graphix">let sum&lt;'a: Number&gt;(@args: 'a) -&gt; 'a
</code></pre>
<p>This is subtly different from the <code>sum</code> examples earlier. This says,
<code>sum</code> is a function that takes any number of arguments of the same
type and returns the same type, and that type must be some kind of
number.</p>
<h3 id="auto-parameters"><a class="header" href="#auto-parameters">Auto Parameters</a></h3>
<p>The compiler often infers type variables (and constrains them) by
itself during the type inference process.</p>
<p>if we compile a function with no type constraints, such as:</p>
<pre><code class="language-graphix">let f = |x, y| x + y
</code></pre>
<p>It's type will be something like:</p>
<pre><code class="language-graphix">val f: fn&lt;
  '_2073: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;, 
  '_2069: Number, 
  '_2067: Number, 
  '_2071: Number
&gt;('_2067, '_2069) -&gt; '_2071 throws '_2073
</code></pre>
<p>The compiler has inferred a bunch of properties here,</p>
<ul>
<li>both arguments must be of type <code>Number</code>, that's what the constraints
on <code>'_2067: Number</code> and <code>_2069: Number</code> mean.</li>
<li>both arguments need not be the same type, hence they are different type variables</li>
<li>the return type will also be a number, hence <code>'_2071: Number</code>, but
it may not be the same type of number as either of the arguments.</li>
<li>the function may throw an arithmetic exception, hence the constraint
on <code>'_2073</code></li>
</ul>
<p>In the shell this rather imposing type signature is made even more
complex by the shell also telling you what type variables are
currently bound to, or <code>unbound</code> if they aren't bound. So in the shell this pops out as,</p>
<pre><code class="language-graphix">〉f
-: fn&lt;'_2073: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;, '_2069: unbound: Number, '_2067: unbound: Number, '_2071: unbound: Number&gt;('_2067: unbound, '_2069: unbound) -&gt; '_2071: unbound throws '_2073: unbound
</code></pre>
<p>The constraint <code>'_2069: unbound: Number</code> is read as. _2069 is not
currently bound to a type but is constrained to type <code>Number</code>. This is
all useful information, even though it's intimidating at first it's
worth putting in the work to learn to decipher it.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Let's decode some complex real-world signatures:</p>
<h3 id="example-1-tui-table-widget"><a class="header" href="#example-1-tui-table-widget">Example 1: TUI Table Widget</a></h3>
<pre><code class="language-graphix">val table: fn(
    ?#header: &amp;Row,
    ?#selected: &amp;i64,
    ?#row_highlight_style: &amp;Style,
    ?#highlight_symbol: &amp;string,
    &amp;Array&lt;&amp;Row&gt;
) -&gt; Widget
</code></pre>
<p>Breaking it down:</p>
<ul>
<li><code>?#header: &amp;Row</code> - optional labeled argument, reference to a Row</li>
<li><code>?#selected: &amp;i64</code> - optional labeled argument, reference to selected index</li>
<li><code>?#row_highlight_style: &amp;Style</code> - optional labeled argument, reference to a Style</li>
<li><code>?#highlight_symbol: &amp;string</code> - optional labeled argument, reference to symbol string</li>
<li><code>&amp;Array&lt;&amp;Row&gt;</code> - required unlabeled argument, reference to array of row references</li>
<li><code>-&gt; Widget</code> - returns a Widget</li>
</ul>
<p>All parameters are references because the table needs to react to changes without rebuilding.</p>
<h3 id="example-2-filter-function"><a class="header" href="#example-2-filter-function">Example 2: Filter Function</a></h3>
<pre><code class="language-graphix">val filter: fn('a, fn('a) -&gt; bool throws 'e) -&gt; 'a throws 'e
</code></pre>
<p>Breaking it down:</p>
<ul>
<li><code>'a</code> - a value of any type</li>
<li><code>fn('a) -&gt; bool throws 'e</code> - a predicate function that:
<ul>
<li>Takes the same type <code>'a</code></li>
<li>Returns bool</li>
<li>Might throw errors of type <code>'e</code></li>
</ul>
</li>
<li><code>-&gt; 'a</code> - returns the same type as input</li>
<li><code>throws 'e</code> - propagates any errors from the predicate</li>
</ul>
<h3 id="example-3-queue-function"><a class="header" href="#example-3-queue-function">Example 3: Queue Function</a></h3>
<pre><code class="language-graphix">val queue: fn(#clock: Any, 'a) -&gt; 'a
</code></pre>
<p>Breaking it down:</p>
<ul>
<li><code>#clock: Any</code> - required labeled argument of any type, just used as an event source</li>
<li><code>'a</code> - a value of any type</li>
<li><code>-&gt; 'a</code> - returns values of the same type</li>
</ul>
<p>Call it like: <code>queue(#clock: my_timer, my_value)</code></p>
<h3 id="example-4-array-map"><a class="header" href="#example-4-array-map">Example 4: Array Map</a></h3>
<pre><code class="language-graphix">val map: fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e
</code></pre>
<p>Breaking it down:</p>
<ul>
<li><code>Array&lt;'a&gt;</code> - array of any type <code>'a</code></li>
<li><code>fn('a) -&gt; 'b throws 'e</code> - transformation function that:
<ul>
<li>Takes type <code>'a</code> (array element type)</li>
<li>Returns type <code>'b</code> (result element type)</li>
<li>Might throw errors of type <code>'e</code></li>
</ul>
</li>
<li><code>-&gt; Array&lt;'b&gt;</code> - returns array of transformed type</li>
<li><code>throws 'e</code> - propagates errors from the transform function</li>
</ul>
<h2 id="quick-reference-table"><a class="header" href="#quick-reference-table">Quick Reference Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Notation</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>'a</code>, <code>'b</code>, <code>'e</code></td><td>Type parameter (generic)</td><td><code>fn('a) -&gt; 'a</code></td></tr>
<tr><td><code>'_23</code>, <code>'_24</code>, <code>'_25</code></td><td>Inferred type parameter (generic)</td><td><code>fn('_23) -&gt; '_23</code></td></tr>
<tr><td><code>?#param</code></td><td>Optional labeled argument</td><td><code>fn(?#x: i64 = 0)</code></td></tr>
<tr><td><code>#param</code></td><td>Required labeled argument</td><td><code>fn(#x: i64)</code></td></tr>
<tr><td><code>@args</code></td><td>Variadic (any number of args)</td><td><code>fn(@args: i64)</code></td></tr>
<tr><td><code>&amp;T</code></td><td>Reference to type T</td><td><code>fn(&amp;string)</code></td></tr>
<tr><td><code>throws 'e</code></td><td>Can throw errors of type 'e</td><td><code>fn() -&gt; i64 throws 'e</code></td></tr>
<tr><td><code>[T, U]</code></td><td>T or U (set/union type)</td><td><code>[i64, null]</code></td></tr>
<tr><td><code>-&gt;</code></td><td>Returns</td><td><code>fn(i64) -&gt; string</code></td></tr>
<tr><td><code>Array&lt;T&gt;</code></td><td>Array of T</td><td><code>Array&lt;string&gt;</code></td></tr>
<tr><td><code>Map&lt;K, V&gt;</code></td><td>Map with keys K, values V</td><td><code>Map&lt;string, i64&gt;</code></td></tr>
<tr><td><code>Error&lt;'e&gt;</code></td><td>Error containing type 'e</td><td><code>Error&lt;\</code>ParseError&gt;`</td></tr>
<tr><td><code>Result&lt;'r, 'e&gt;</code></td><td>Success 'r or Error 'e</td><td><code>Result&lt;i64, \</code>Err&gt;`</td></tr>
<tr><td><code>Option&lt;'a&gt;</code></td><td>Value 'a or null</td><td><code>Option&lt;string&gt;</code></td></tr>
</tbody></table>
</div>
<h2 id="tips-for-reading-signatures"><a class="header" href="#tips-for-reading-signatures">Tips for Reading Signatures</a></h2>
<ol>
<li><strong>Start with the basics</strong> - identify parameters and return type</li>
<li><strong>Look for type parameters</strong> - they tell you about genericity</li>
<li><strong>Check for optional/labeled args</strong> - they indicate flexibility in calling</li>
<li><strong>Note reference types</strong> - important for reactivity</li>
<li><strong>Watch for throws</strong> - you'll need error handling</li>
<li><strong>Don't panic at complexity</strong> - break it down piece by piece</li>
</ol>
<p>Remember: you don't need to memorize these patterns. As you use Graphix, you'll naturally become familiar with common signatures. This guide is here whenever you need a reminder!</p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="core/./fundamental_types.html">Fundamental Types</a> - Built-in types and type sets</li>
<li><a href="core/../functions/overview.html">Functions</a> - Creating and using functions</li>
<li><a href="core/./error.html">Error Handling</a> - Working with errors and the throws system</li>
<li><a href="core/../udt/references.html">References</a> - Deep dive into reference types</li>
<li><a href="core/../udt/overview.html">User Defined Types</a> - Structural typing and custom types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-binds"><a class="header" href="#let-binds">Let Binds</a></h1>
<p>Let bindings introduce names that are visible in their scope after they are
defined.</p>
<pre><code class="language-graphix">let x = 2 + 2 + x; // compile error x isn't defined yet
let y = x + 1 // ok
</code></pre>
<p>The same name can be used again in the same scope, it will shadow the previous
value.</p>
<pre><code class="language-graphix">let x = 1;
let x = x + 1; // ok uses the previous definition
x == 2 // true
</code></pre>
<p>You can annotate the binding with a type, which will then be enforced at compile
time. Sometimes this is necessary in order to help type inference.</p>
<pre><code class="language-graphix">let x: Number = 1; // note x will be of type Number even though it's an i64
let y: string = x + 1; // compile time type error
</code></pre>
<p>You can use patterns in let binds as long as they will always match.</p>
<pre><code class="language-graphix">let (x, y) = (3, "hello"); // binds x to 3 and y to "hello"
x == 3; // true
y == "hello" // true
</code></pre>
<p>You can mix type annotations with pattern matches</p>
<pre><code class="language-graphix">let (x, y): (i64, string) = (3, "hello")
</code></pre>
<p>You can assign documentation to a let bind using a <code>///</code> comment. Documentation
will be displayed in the shell when the user tab completes and will be made
available by the lsp server.</p>
<pre><code class="language-graphix">// this is a normal comment
let x = 1;
/// this is documentation for y
let y = 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect"><a class="header" href="#connect">Connect</a></h1>
<p>Connect, written <code>x &lt;- expr</code> is where things get interesting in Graphix. The
sharp eyed may have noticed that up until now there was no way to introduce a
cycle in the graph. Connect is the only graph operator in Graphix, it allows you
to connect one part of the graph to another by name, causing the output of the
right side to flow to the name on the left side. Consider,</p>
<pre><code class="language-graphix">let x = "off"
x &lt;- time::timer(duration:1.0s, false) ~ "on"
print(x)
</code></pre>
<p>This program will first print <code>off</code>, and after 1 second it will print <code>on</code>. Note
the <code>~</code> operator means, when the expression on the left updates return the
current value of the expression on the right (called the sample operator). The
graph we created looks like,</p>
<pre><code>const("off") ────────────────&gt; "x" ──────&gt; print
                                 ▲
                                 │
                                 │
           time::timer ──&gt; sample
                            ▲
                            │
                            │
                      const("on")
</code></pre>
<p>We can also build an infinite loop with connect. This won't crash the program,
and it won't stop other parts of the program from being evaluated,</p>
<pre><code class="language-graphix">let x = 0;
x &lt;- x + 1;
print(x)
</code></pre>
<p>This program will print all the i64s from 0 to MAX and then will wrap around. It
will print numbers forever. You might notice, and you might wonder, why does it
start from zero, shouldn't it start from 1? After all we increment x BEFORE the
print right? Well, no, not actually, it will start at 0, for the same reason
this infinite loop won't lock up the program or cause other expressions not to
be evaluated. Graphix programs are evaluated in cycles, a batch of updates from
the network, timers, and other IO is processed into a set of all events that
happened "now", then the parts of the program that care about those particular
events are evaluated, and then the main loop goes back to waiting for events.</p>
<p>What connect does is it schedules an update to <code>x</code> for the next cycle, the
current cycle proceeds as normal to it's conclusion as if the connect didn't
happen yet, because it didn't. In the above case the event loop would never
wait, because there is always work to do adding 1 to <code>x</code>, however it will still
check for other events every cycle.</p>
<p>When combined with other operations, specifically select, connect becomes a
powerful general looping construct, and is the only way to write a loop in
Graphix. A quick example,</p>
<pre><code class="language-graphix">let count = {
  let x = 0;
  select x {
    n if n &lt; 10 =&gt; x &lt;- x + 1,
    _ =&gt; never() // never() never updates
  };
  x
};
count
</code></pre>
<p>This program creates a bind <code>count</code> that will update with the values 0 to 10. If
you put it in a file <code>test.gx</code> and execute it using <code>graphix test.gx</code> it will
print 0 to 10 and then wait.</p>
<pre><code>$ graphix test.gx
0
1
2
3
4
5
6
7
8
9
10
</code></pre>
<h3 id="is-connect-mutation"><a class="header" href="#is-connect-mutation">Is Connect Mutation?</a></h3>
<p>Connect causes let bound names to update, so it's kind of mutation. Kind of. A
better way to think about it is that every let bound value is a pipe with
multiple producers and multiple consumers. Connect adds a new producer to the
pipe. The values being produced are immutable, an array <code>[1, 2, 3]</code> will always
and forever be <code>[1, 2, 3]</code>, but a new array <code>[1, 2, 3, 4]</code> might be pushed into
the same pipe <code>[1, 2, 3]</code> came from, and that might make it appear that the
array changed. The difference is, if you captured the original <code>[1, 2, 3]</code> and
put it somewhere, a new <code>[1, 2, 3, 4]</code> arriving on the pipe can't change the
original array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block is a group of code between <code>{</code> and <code>}</code> that has it's own scope, and
evaluates to the last value in the block. Expressions in a block are <code>;</code>
separated, meaning every expression except the last one must end in a <code>;</code> and
it is illegal for a block to have just one expression (it will not parse).</p>
<p>You can use blocks to hide intermediate variables from outer scopes, and to
group code together in a logical way.</p>
<pre><code class="language-graphix">let important_thing = {
  let x = 0;
  let y = x + 1;
  43 - y
};

x; // compile error, x isn't in scope
y; // compile error, y isn't in scope
important_thing
</code></pre>
<p>This program won't compile because you can't reference y and x from
outside the block scope. Blocks are valid anywhere an expression is
valid, and they are just expressions. They will become very important
when we introduce lambda expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">Use</a></h1>
<p>Use allows you to bring names in modules into your current scope so they can be used without prefixing.</p>
<pre><code class="language-graphix">net::subscribe(...); // call subscribe in the net module
use net;
subscribe(...) // same function
</code></pre>
<p>Use is valid anywhere expressions are valid</p>
<pre><code class="language-graphix">let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
list
</code></pre>
<p>will print <code>[2, 4, 6, 8, 10]</code></p>
<pre><code class="language-graphix">let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
map(list, |x| x * 2)
</code></pre>
<p>will not compile, e.g.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    at line: 5, column: 1 map not defined
</code></pre>
<p>Use shadows earlier declarations in it's scope. Consider,</p>
<pre><code class="language-graphix">let map = |a, f| "hello you called map!";
let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
(list, map(list, |x| x * 2))
</code></pre>
<p>prints</p>
<pre><code>$ graphix test.gx
([2, 4, 6, 8, 10], "hello you called map!")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Select lets us create a graph node with multiple possible output paths that
will choose one path for each value based on a set of conditions. Kind of like,</p>
<pre><code>                     ┌─────────────────────&gt; if foo &gt; 0 =&gt; ...
                     │
                     │
ref(foo) ──&gt; select ─┼─────────────────────&gt; if foo &lt; 0 =&gt; ...
                     │
                     │
                     └─────────────────────&gt; otherwise =&gt; ...
</code></pre>
<p>is written as</p>
<pre><code class="language-graphix">select foo {
  n if n &gt; 0 =&gt; ...,
  n if n &lt; 0 =&gt; ...,
  n =&gt; ...
}
</code></pre>
<p>select takes an expression as an argument and then evaluates one or more "arms".
Each arm consists of an optional type predicate, a destructuring pattern, and an
optional guard clause. If the type predicate matches, the pattern matches, and
the guard evaluates to true then the arm is "selected". Only one arm may be
selected at a time, the arms are evaluated in lexical order, and first arm to be
selected is chosen as the one and only selected arm.</p>
<p>The code on the right side of the selected arm is the only code that is
evaluated by select, all other code is "asleep", it will not be evaluated
until it is selected (and if it has netidx subscriptions or published values
they will be unsubscribed and unpublished until it is selected again).</p>
<h2 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h2>
<p>Consider we want to select from a value of type <code>[Array&lt;i64&gt;, i64, null]</code>,</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This program will print 42, 15, 7 and then wait. The compiler will check that
you have handled all the possible cases. If we remove the null case from this
select we will get a compile error.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    missing match cases type mismatch [i64, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>If you read this carefully you can see that the compiler is building up a set of
types that we did match, and checking that it contains the argument type. This
goes both ways, a match case that could never match is also an error.</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  f64 as n =&gt; cast&lt;i64&gt;(n)?,
  null as _ =&gt; 42
}
</code></pre>
<p>Here we've added an <code>f64</code> match case, but the argument type can never contain an
<code>f64</code> so we will get a compile error.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern f64 will never match null, unused match cases
</code></pre>
<p>The diagnostic message gives you an insight into the compiler's thinking. What
it is saying is that, by the time it's gotten to looking at the <code>f64</code> pattern,
the only type left in the argument that hasn't already been matched is <code>null</code>,
and since <code>f64</code> doesn't unify with <code>null</code> it is sure this pattern can never
match.</p>
<p>Guarded patterns can always not match because of the guard, so they do not
subtract from the argument type set. You are required to match without a guard
at some point. No analysis is done to determine if your guard covers the entire
range of a type.</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n if n &gt; 10 =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This will fail with a missing match case because the <code>i64</code> pattern is guarded
and no unguarded pattern exists that matches <code>i64</code>.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    missing match cases type mismatch [null, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>This is the same error you would get if you omitted the <code>i64</code> match case
entirely.</p>
<h2 id="matching-structure"><a class="header" href="#matching-structure">Matching Structure</a></h2>
<p>The type predicate is optional in a pattern, and the more commonly used pattern
is structural. Graphix supports several kinds of structural matching,</p>
<ul>
<li>array slices</li>
<li>tuples</li>
<li>structs</li>
<li>variants</li>
<li>literals, ignore</li>
</ul>
<p>NB: In most contexts you can match the entire value as well as parts of it's
structure by adding a <code>v@</code> pattern before the pattern. You will see this in many
of the examples.</p>
<h3 id="slice-patterns"><a class="header" href="#slice-patterns">Slice Patterns</a></h3>
<p>Suppose we want to classify arrays that have at least two elements vs arrays
that don't, and we want to return a variant with a triple of the first two
elements and the rest of the array or `Short with the whole array.</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4];
a &lt;- [1];
a &lt;- [5, 6];
select a {
  [x, y, tl..] =&gt; `Ok((x, y, tl)),
  a =&gt; `Short(a)
}
</code></pre>
<p>This program will print,</p>
<pre><code>$ graphix test.gx
`Ok((1, 2, [3, 4]))
`Short([1])
`Ok((5, 6, []))
</code></pre>
<p>The following kinds of slice patterns are supported,</p>
<ul>
<li>
<p>whole slice, with binds, or literals, e.g. <code>[1, x, 2, y]</code> matches a 4 element
array and binds it's 2nd and 4th element to <code>x</code> and <code>y</code> respectively.</p>
</li>
<li>
<p>head pattern, like the above program, e.g. <code>[(x, y), ..]</code> matches the first
pair in an array of pairs and ignores the rest of the array, binding the pair
elements to <code>x</code> and <code>y</code>. You can also name the remainder, as we saw, e.g.
<code>[(x, y), tl..]</code> does the same thing, but binds the rest of the array to <code>tl</code></p>
</li>
<li>
<p>tail pattern, just like the head pattern, but for the end of the array. e.g.
<code>[hd.., {foo, bar}]</code> matches the last element of an array of structs with
fields <code>foo</code> and <code>bar</code>, binding <code>hd</code> to the array minus the last element, and
<code>foo</code> to field foo and <code>bar</code> to field bar.</p>
</li>
</ul>
<p>Structure patterns (all of the different types) can be nested to any depth.</p>
<h3 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple Patterns</a></h3>
<p>Tuple patterns allow you to match tuples. Compared to slice patterns they are
fairly simple. You must specify every field of the tuple, you can choose to bind
it, or ignore it with <code>_</code>. e.g.</p>
<p><code>("I", "am", "a", "happy", "tuple", w, _, "patterns")</code></p>
<h3 id="struct-patterns"><a class="header" href="#struct-patterns">Struct Patterns</a></h3>
<p>Struct patterns, like tuple patterns, are pretty simple.</p>
<ul>
<li><code>{ x, y }</code> if you like the field names then there is no need to change them</li>
<li><code>{ x: x_coord, y: y_coord }</code> but if you need to use a different name you can</li>
<li><code>{ x, .. }</code> you don't have to write every field</li>
</ul>
<p>Consider</p>
<pre><code class="language-graphix">let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  {x, y: _} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  {y, x: _} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>does some 2d bounds checking, and will output</p>
<pre><code>$ graphix test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>You might be tempted to replace <code>y: _</code> with <code>..</code> as it would be shorter.
Unfortunately this will confuse the type checker, because the Graphix type system
is structural saying <code>{x, ..}</code> without any other information could match ANY
struct with a field called <code>x</code>. This is currently too much for the type checker
to handle,</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern {x: '_1040} will never match {x: i64, y: i64}, unused match cases
</code></pre>
<p>The error is slightly confusing at first, until you understand that since we
don't know the type of <code>{x, ..}</code> we don't think it will match the argument type,
and therefore the match case is unused. This actually saves us a lot of trouble
here, because the last match is exhaustive, if we didn't check for unused match
cases this program would compile, but it wouldn't work. You can easily fix this
by naming the type, and for larger structs it's often worth it if you only need
a few fields.</p>
<pre><code class="language-graphix">type T = {x: i64, y: i64};
let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  T as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  T as {y, ..} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>Here since we've included the type pattern <code>T</code> in our partial patterns the
program compiles and runs.</p>
<pre><code>$ graphix test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>Note that we never told the compiler that <code>a</code> is of
type <code>T</code>. In fact <code>T</code> is just an alias for <code>{x: i64, y: i64}</code> which is the type
of <code>a</code>. We could in fact write our patterns without the alias,</p>
<p><code>{x: i64, y: i64} as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall</code></p>
<p>The type alias just makes the code less verbose without changing the semantics.</p>
<h3 id="variant-patterns"><a class="header" href="#variant-patterns">Variant Patterns</a></h3>
<p>Variant patterns match variants. Consider,</p>
<pre><code class="language-graphix">let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]"
}
</code></pre>
<p>produces</p>
<pre><code>$ graphix test.gx
"it's bare, no argument"
"it has an arg 42"
"it's big `MoreArg(\"hello world\", 42) with args \"hello world\" and 42"
</code></pre>
<p>Variant patterns enforce the same kinds of match case checking as all the other pattern types</p>
<pre><code class="language-graphix">let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]",
  `Wrong =&gt; "this won't compile"
}
</code></pre>
<p>yields</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern `Wrong will never match [`Arg(i64), `MoreArg(string, i64)], unused match cases
</code></pre>
<h3 id="literals-ignore"><a class="header" href="#literals-ignore">Literals, Ignore</a></h3>
<p>You can match literals as well as bind variables, as you may have noticed, and
the special pattern <code>_</code> means match anything and don't bind it to a variable.</p>
<h3 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h3>
<p>A significant missing feature from patterns vs other languages is support for
multiple alternative patterns in one arm. I plan to add this at some point.</p>
<h2 id="select-and-connect"><a class="header" href="#select-and-connect">Select and Connect</a></h2>
<p>Using select and connect together is one way to iterate in Graphix. Consider,</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4, 5];
let len = 0;
select a {
  [x, tl..] =&gt; {
    len &lt;- len + 1;
    a &lt;- tl
  },
  _ =&gt; len
}
</code></pre>
<p>produces</p>
<pre><code>$ graphix test.gx
5
</code></pre>
<p>This is not normally how we would get the length of an array in Graphix, or even
how we would do something with every element of an array (see <code>array::map</code> and
<code>array::fold</code>), however it illustrates the power of select and connect together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Errors in Graphix are represented by the <code>Error&lt;'a&gt;</code> type. A new instance of
which can be created with the <code>error</code> function. e.g.</p>
<pre><code class="language-graphix">〉error(`Foo)
-: Error&lt;'a: `Foo&gt;
error:"Foo"
</code></pre>
<h2 id="try-catch-and-"><a class="header" href="#try-catch-and-">Try Catch and ?</a></h2>
<p>While errors are normal values, and can be matched in select, they can also be
thrown and handled like exceptions. The <code>?</code> operator throws errors generated by
the expression on it's left to the nearest try catch block in dynamic scope. for
example,</p>
<pre><code class="language-graphix">〉let a = [1, 2, 3, 4]
〉try a[15]? catch(e) =&gt; println(e)
-: i64
error:[["cause", null], ["error", ["ArrayIndexError", "array index out of bounds"]], ["ori", [["parent", null], ["source", "Unspecified"], ["text", "try a[15]? catch(e) =&gt; println(e)"]]], ["pos", [["column", i32:5], ["line", i32:1]]]]
</code></pre>
<p>Catches the array index error and prints it's full context to stdout. Every
error raised with <code>?</code> is wrapped in an <code>ErrChain</code> struct, the full definition of
which is,</p>
<pre><code class="language-graphix">type Pos = {
    line: i32,
    column: i32
};

type Source = [
    `File(string),
    `Netidx(string),
    `Internal(string),
    `Unspecified
];

type Ori = {
    parent: [Ori, null],
    source: Source,
    text: string
};

type ErrChain&lt;'a&gt; = {
    cause: [ErrChain&lt;'a&gt;, null],
    error: 'a,
    ori: Ori,
    pos: Pos
}
</code></pre>
<p>This gives the full context of where the error happened, and whether it was
previously caught and reraised, giving the full history back to the first time
it was ever raised.</p>
<p>The scope is dynamic, not lexical, mirroring exception systems that unwind the
stack,</p>
<pre><code class="language-graphix">〉let div0 = try |x| x / 0 catch(e) =&gt; println(e ~ "never triggered")
〉try div0(0) catch(e) =&gt; println(e)
-: i64
error:[["cause", null], ["error", ["ArithError", "attempt to divide by zero"]], ["ori", [["parent", null], ["source", "Unspecified"], ["text", "let div0 = try |x| x / 0 catch(e) =&gt; println(e ~ \"never triggered\")"]]], ["pos", [["column", i32:20], ["line", i32:1]]]]
</code></pre>
<p>The catch surrounding the function call site, not the definition site, is the
one triggered.</p>
<h3 id="try-catch-block-value"><a class="header" href="#try-catch-block-value">Try Catch Block Value</a></h3>
<p>The try catch block always evaluates to the last value inside the try catch,
never to the value of the catch block. An error being raised to try catch does
not stop the execution of nodes in the try catch.</p>
<h2 id="checked-errors"><a class="header" href="#checked-errors">Checked Errors</a></h2>
<p>Graphix function types are annotated by the type of error they might raise. In
most cases this is automatic, but for some higher order functions it may be
necessary to specify it explicitly. For example array map has type
<code>fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e</code> indicating that
while the map function itself does not throw any errors, it will throw any
errors the function passed to it throws. This is all in the service of being
able to statically check the type of thrown errors, for example,</p>
<pre><code class="language-graphix">let a = [0, 1, 2, 3];
try a[0]? + a[1]?
catch(e) =&gt; select (e.0).error {
    `ArithError(s) =&gt; println("arithmetic operation error [s]"),
    `ArrayIndexError(s) =&gt; println("array index error [s]")
}
</code></pre>
<p>There are two types of errors that can happen in this example, and the compiler
knows that. If you were to omit one of them, then the example would not compile.
Suppose we remove the pattern for ArrayIndexError, we would get,</p>
<pre><code>Error: in file "test.gx"

Caused by:
    0: at: line: 3, column: 13, in: select (e.0).error {`ArithError(s) =&gt; ..
    1: missing match cases type mismatch `ArithError('_1897: string) does not contain '_1895: [`ArithError(string), `ArrayIndexError(string)]
</code></pre>
<p>You'll recognize that this is just the normal select exhaustiveness checking at
work. Since errors are just normal types, the important point is the compiler
knows the type of every error at compile time, everything else flows from there.</p>
<h2 id="unhandled-errors"><a class="header" href="#unhandled-errors">Unhandled Errors</a></h2>
<p>By default when evaluating a file, the compiler will print a warning whenever an
error raised by <code>?</code> is not handled explicitly by a try catch block. Arithmetic
errors such as overflow do not generate this warning by default. Using <code>-W</code>
flags you can change the compilers behavior in this respect.</p>
<h2 id="the--operator-aka-or-never"><a class="header" href="#the--operator-aka-or-never">The $ Operator, aka Or Never</a></h2>
<p>The <code>$</code> operator goes in the same position as <code>?</code>, and is best described as "or
never". If the expression on it's left is a non error, then <code>$</code> doesn't do
anything, otherwise it returns nothing. This is a concise way of writing,</p>
<pre><code class="language-graphix">select might_fail(1, 2, 3) {
  error as _ =&gt; never(),
  v =&gt; v
}
</code></pre>
<p>can instead be written as,</p>
<pre><code class="language-graphix">might_fail(1, 2, 3)$
</code></pre>
<p>The <code>$</code> operator should be used cautiously, as it silently ignores
errors, however often it is useful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions are first class values. They can be stored in variables, in data
structures, and they can be passed around to other functions. Etc. They are
defined with the syntax,</p>
<pre><code class="language-graphix">|arg0, arg1, ...| body
</code></pre>
<p>This is often combined with a let bind to make a named function.</p>
<pre><code class="language-graphix">let f = |x, y| x + y + 1
</code></pre>
<p><code>f</code> is now bound to the lambda that adds it's two arguments and 1. You can also
use structure patterns in function arguments as long as the pattern will always
match.</p>
<pre><code class="language-graphix">let g =|(x, y), z| x + y + z
</code></pre>
<p>Type annotations can be used to constrain the argument types and the return
type,</p>
<pre><code class="language-graphix">let g = |(x, y): (f64, f64), z: f64| -&gt; f64 x + y + z
</code></pre>
<p>Functions are called with the following syntax.</p>
<pre><code class="language-graphix">f(1, 1)
</code></pre>
<p>Would return 3. If the function is stored in a data structure, then sometimes
you need parenthesis to call it.</p>
<pre><code class="language-graphix">(s.f)(1, 1)
</code></pre>
<p>Would call the function <code>f</code> in the struct <code>s</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labeled-and-optional-arguments"><a class="header" href="#labeled-and-optional-arguments">Labeled and Optional Arguments</a></h1>
<p>Functions can have labeled and also optional arguments. Labeled arguments need
not be specified in order, and optional arguments don't need to be specified at
all. When declaring a function you must specify the labeled and optional
arguments before any non labeled arguments.</p>
<pre><code class="language-graphix">let f = |#lbl1, #lbl2, arg| ...
</code></pre>
<p>In this case lbl1 and 2 are not optional, but are labeled. You can call f with
either labeled argument in either order. e.g. <code>f(#lbl2, #lbl1, a)</code>.</p>
<pre><code class="language-graphix">let f = |#opt = null, a| ...
</code></pre>
<p><code>opt</code> need not be specifed when <code>f</code> is called, if it isn't specified then it
will be <code>null</code>. e.g. <code>f(2)</code> is a valid way to call <code>f</code>. You can also apply type
constraints to labeled and optional arguments.</p>
<pre><code class="language-graphix">let f = |#opt: [i64, null] = null, a| ..
</code></pre>
<p>Specifies that <code>opt</code> can be either an <code>i64</code> or <code>null</code> and by default it is null.
The compiler implements subtyping for functions with optional arguments. For
example if you write a function that takes a function with a labeled argument
<code>foo</code>, you can pass any function that has a labeled argument <code>foo</code>, even if it
also has other optional arguments. The non optional and non labeled arguments
must match, of course. For example,</p>
<pre><code class="language-graphix">let f = |g: fn(#foo:i64, i64) -&gt; i64, x: i64| g(#foo:x, x);
let g = |#foo:i64, #bar: i64 = 0, x: i64| foo + bar + x;
f(g, 42) // valid call
</code></pre>
<p>outputs</p>
<pre><code>$ graphix test.gx
84
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-closures"><a class="header" href="#lexical-closures">Lexical Closures</a></h1>
<p>Functions can reference variables outside of their definition. These variables
are captured by the function definition, and remain valid no matter where the
closure is called. For example,</p>
<pre><code class="language-graphix">let f = {
  let v = cast&lt;i64&gt;(net::subscribe("/local/foo")$)$;
  |n| v + n
};
f(2)
</code></pre>
<p><code>f</code> captures <code>v</code> and can use it even when it is called from a scope where <code>v</code>
isn't visible. Closures allow functions to encapsulate data, just like an object
in OOP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-are-first-class-values"><a class="header" href="#functions-are-first-class-values">Functions are First Class values</a></h1>
<p>We can store a function in a structure, which can itself be stored in a data
structure, a file, or even sent across the network to another instance of the
same program. Here we build a struct that maintains a count, and a function to
operate on the count, returning a new struct of the same type with a different
count.</p>
<pre><code class="language-graphix">type T = { count: i64, f: fn(T) -&gt; T };
let t = { count: 0, f: |t: T| {t with count: t.count + 1} };
(t.f)(t)
</code></pre>
<p>when run this example will output,</p>
<pre><code>{count: 1, f: 158}
</code></pre>
<p>158 is the lambda id, it's the actual value that is stored to represent a
function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="late-binding"><a class="header" href="#late-binding">Late Binding</a></h1>
<p>Functions are always late bound. Late binding means that the runtime actually
figures out which function is going to be called at runtime, not compile time.
At compile time we only know the type of the function we are going to call. This
complicates the compiler significantly, but it is a powerful abstraction tool.
For example we can create two structs of type <code>T</code> that each contain a different
implementation of <code>f</code>, and we can use them interchangibly with any function that
accepts a <code>T</code>. In this simple example we create one implementation of <code>f</code> that
increments the count, and one that decrements it.</p>
<pre><code class="language-graphix">type T = { count: i64, f: fn(T) -&gt; T };
let ts: Array&lt;T&gt; = [
  { count: 0, f: |t: T| {t with count: t.count + 1} },
  { count: 0, f: |t: T| {t with count: t.count - 1} }
];
let t = array::iter(ts);
(t.f)(t)
</code></pre>
<p>when run this example will output,</p>
<pre><code>{count: 1, f: 158}
{count: -1, f: 159}
</code></pre>
<p>You can clearly see that f is bound to different functions by the runtime since
the lambda ids (158 and 159) are different. While Graphix is not an object
oriented language, you can use closures and late binding to achieve some of the
same outcomes as OOP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>While the compiler does a pretty good job of inferring the types of
functions, sometimes you want to express a constraint that can't be
inferred. Suppose we wanted to write a function that you can pass any
type of number to, but it has to be the same type for both arguments,
and the return type will be the same as the argument type. We can say
that using type variables and constraints in our annotations.</p>
<pre><code class="language-graphix">〉let f = 'a: Number |x: 'a, y: 'a| -&gt; 'a x + y
〉f
-: fn&lt;'a: unbound: Number, '_2101: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;&gt;('a: unbound, 'a: unbound) -&gt; 'a: unbound throws '_2101: unbound
160
</code></pre>
<p>In type annotations of lambda expressions,</p>
<ul>
<li>The constraints come before the first <code>|</code>, separated by commas if there are
multiple constrained type variables. e.g. <code>'a: Number</code></li>
<li>Each argument may optionally have a <code>: Type</code> after it, and this will set it's
type, e.g. <code>x: 'a</code></li>
<li>After the second <code>|</code> you can optionally include an <code>-&gt; Type</code> which will set
the return type of the function, e.g. <code>-&gt; 'a</code></li>
<li>After the return type, you can optionally specify a throws type, <code>throws Type</code>, which will set the type that is thrown by the function</li>
</ul>
<p>When a function type is printed, the stuff between the <code>fn&lt;&gt;</code> are the
type constraints, the syntax in this readout is a colon separated list
of,</p>
<ul>
<li>type variable name, for example '_2073</li>
<li>current value, or unbound if there is no current value</li>
<li>constraint type</li>
</ul>
<pre><code>fn&lt;'a: unbound: Number, 
   '_2101: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;&gt;
('a: unbound, 'a: unbound) -&gt; 'a: unbound throws '_2101: unbound
</code></pre>
<p>We can remove the (unbound) current values and it becomes easier to read,</p>
<pre><code>fn&lt;'a: Number,
   '_2101: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;&gt;
('a, 'a) -&gt; 'a throws '_2101
</code></pre>
<p>We just have two variables now, <code>'a</code> representing both argument types
and the return type, and <code>'_2101</code> representing the throws type. We can
still call this <code>f</code> with any number type,</p>
<pre><code class="language-graphix">〉f(1.212, 2.0)
-: f64
3.2119999999999997
</code></pre>
<p>However notice that we get back the explicit type we passed in,</p>
<pre><code class="language-graphix">〉f(2, 2)
-: i64
4
</code></pre>
<p>In one case <code>f64</code>, in the other <code>i64</code>. We can't pass numbers of
different types to the same call,</p>
<pre><code class="language-graphix">〉f(1, 1.2)
error: in expr

Caused by:
    0: at: line: 1, column: 6, in: f64:1.2
    1: type mismatch 'a: i64 does not contain f64
</code></pre>
<p>Here the compiler is saying that <code>'a</code> is already initialized as <code>i64</code> and <code>i64</code>
doesn't unify with <code>f64</code>.</p>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h2>
<p>Since functions are first class, they can take other functions as arguments, and
even return functions. These relationships can be often inferred automatically
without issue, but sometimes annotations are required.</p>
<pre><code class="language-graphix">〉 let apply = |x: 'a, f: fn('a) -&gt; 'b throws 'e| -&gt; 'b throws 'e f(x)
〉 apply
-: fn&lt;'e: unbound: _&gt;('a: unbound, fn('a: unbound) -&gt; 'b: unbound throws 'e: unbound) -&gt; 'b: unbound throws 'e: unbound
163
</code></pre>
<p>Here we've specified a single argument apply, it takes an argument, and a
function <code>f</code>, and calls <code>f</code> on the argument. Note that we've explicitly said
that whatever type of error <code>f</code> throws, <code>apply</code> will throw as well. That was
constrained by the compiler to <code>_</code> meaning basically this could throw anything
or also not throw at all, it just depends on <code>f</code>.</p>
<p>We can see a more practical example in the type of <code>array::map</code> (this
implementation of which I will not repeat here), which is,</p>
<pre><code>fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e
</code></pre>
<p>So map takes an array of <code>'a</code>, and a function mapping <code>'a</code> to <code>'b</code> and possibly
throwing <code>'e</code> and returns an array of <code>'b</code> possibly throwing <code>'e</code>.</p>
<h2 id="implicit-polymorphism"><a class="header" href="#implicit-polymorphism">Implicit Polymorphism</a></h2>
<p>All functions are polymorphic, even without annotations, argument and return
types are inferred at each call site, and thus may differ from one site to
another. Any internal constraints are calculated when the definition is compiled
and are enforced at each call site. For example consider,</p>
<pre><code class="language-graphix">〉let f = |x, y| x + y
〉f
-: fn&lt;'_2073: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;, '_2069: unbound: Number, '_2067: unbound: Number, '_2071: unbound: Number&gt;('_2067: unbound, '_2069: unbound) -&gt; '_2071: unbound throws '_2073: unbound
159
</code></pre>
<p>The type is a bit of a mouthfull, lets format it a bit so it's easier to read.</p>
<pre><code>fn&lt;'_2073: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;,
   '_2069: unbound: Number,
   '_2067: unbound: Number,
   '_2071: unbound: Number&gt;
('_2067: unbound, '_2069: unbound) -&gt; '_2071: unbound throws '_2073: unbound
</code></pre>
<p>Removing the unbounds,</p>
<pre><code>fn&lt;'_2073: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;,
   '_2069: Number,
   '_2067: Number,
   '_2071: Number&gt;
('_2067, '_2069) -&gt; '_2071 throws '_2073
</code></pre>
<p>Here we can see that <code>'_2067</code>, <code>'_2069</code>, and <code>'_2071</code> represent the two
arguments and the return type of the function. They are all unbound, meaning
that when the function is used they can have any type. They are also all
constrained to <code>Number</code>, and this will be enforced when the function is called,
it's arguments must be numbers and it will return a number. We learned this
because internally the function uses <code>+</code>, which operates on numbers, this
constraint was then propagated to the otherwise free variables representing the
args and the return type.</p>
<p>So in plain English this says that the arguments to the function can by any type
as long as it is a number, and the function will return some type which is a
number. None of the three numbers need to be the same type of number.</p>
<p>Finally lets address <code>throws '_2073</code>. This states that the function may throw an
error, and if it does it's type will be <code>'_2073</code>, which in this case is
constrained to be</p>
<p><code>Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;</code>.</p>
<p>This is what happens in the case of overflow, underflow, and other arithmetic
errors. The <code>throws</code> clause of the type is used by the <code>try catch(e) =&gt; ...</code>
expression to compute the type of <code>e</code>, which is just the union of all the throws
types within the <code>try catch</code>.</p>
<p>We can indeed call <code>f</code> with different number types, and it works just fine,</p>
<pre><code class="language-graphix">〉f(1.0, 1)
-: Number
2
</code></pre>
<p>The type we get back really depends on the values we pass. For example,</p>
<pre><code class="language-graphix">〉f(1.1212, 1)
-: Number
2.1212
</code></pre>
<p>Wherever we use <code>f</code> the compiler will force us to handle every possible case in
the <code>Number</code> type</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>Functions can be recursive, however there is currently no tail call optimization,
so you can easily exhaust available stack space. With that warning aside, lets
write a recursive function to add up pairs of numbers in an array,</p>
<pre><code class="language-graphix">let rec add_pairs = 'a: Number |a: Array&lt;'a&gt;| -&gt; Array&lt;'a&gt; select a {
  [e0, e1, tl..] =&gt; array::push_front(add_pairs(tl), e0 + e1),
  a =&gt; a
}
</code></pre>
<p>running this we see,</p>
<pre><code class="language-graphix">〉add_pairs([1, 2, 3, 4, 5])
-: Array&lt;'a: i64&gt;
[3, 7, 5]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="detailed-semantics"><a class="header" href="#detailed-semantics">Detailed Semantics</a></h1>
<p>Considering the underlying execution model functions might be better described
as "polymorphic graph templates", in that they allow you to specify a part of
the graph once, and then use it multiple times with different types each time.
Most of the time this difference in semantics doesn't matter. Most of the time.
Consider,</p>
<pre><code class="language-graphix">let f = |x, y| x + y + y;
let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
f(n, 1)
</code></pre>
<p>What happens here? Does <code>f</code> get "called" every time <code>n</code> updates? Does it only
work for the first <code>n</code>? Does it explode? Lets transform it like the compiler
would in order to understand it better,</p>
<pre><code class="language-graphix">let f = |x, y| x + y + y;
let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
n + 1 + 1
</code></pre>
<p>The "arguments" to the function call were plugged into the holes in the graph
template and then the whole template is copied to the call site, and from then
on the graph runs as normal.</p>
<p>So when <code>n</code> updates, the call site will return <code>n</code> + 2, since <code>1</code>
never updates we don't have to worry about it, however this same flow
applies when multiple arguments could update. In this case we're just
having a philosophical discussion about how call sites are
implemented, however it DOES actually matter sometimes.</p>
<h2 id="where-function-semantics-matter"><a class="header" href="#where-function-semantics-matter">Where Function Semantics Matter</a></h2>
<p>Lets revisit an earlier example where we used select and connect to find the
length of an array. Suppose we want to generalize that into a function,</p>
<pre><code class="language-graphix">let len = |a: Array&lt;'a&gt;| {
  let sum = 0;
  select a {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      a &lt;- tl
    },
    _ =&gt; sum
  }
}
</code></pre>
<p>Here we have a function that takes an array with any element type and
returns it's length. Brilliant, lets call it,</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4, 5];
len(a)
</code></pre>
<p>and when we run this we get,</p>
<pre><code>$ graphix test.gx
5
</code></pre>
<p>That's the right answer. Are we done? Noooooooo. No we are not done. Lets see
what happens if we do,</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4, 5];
a &lt;- [1, 2, 3];
a &lt;- [1, 2];
len(a)
</code></pre>
<p>this results in,</p>
<pre><code>$ graphix test.gx
4
</code></pre>
<p>What!? That's not even wrong. That's just nonsense, what happened? The key to
understanding this problem is that there is just one call site, which means we
instantiated this little reusable bit of graph one time, just one time. That
means there is just one <code>sum</code>, one <code>a</code>, basically just one graph. When we use
connect to iterate we are using graph traversal cycles to do a new element of
the array every cycle until we are done. It will take 5 cycles for the first
array to be done, and that's the problem, because we update <code>a</code> with a whole new
array in cycle 1 and again in cycle 2. That's why we get 4, it's determanistic,
we will get 4 every time.</p>
<ul>
<li>the first cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>tl</code> (it's not the
same variable as the outer <code>a</code>, which is why the chaos isn't even greater). But
the outer <code>a</code> also gets set to <code>[1, 2, 3]</code> and that overwrites the inner set
because it happens after it (because that's just the way the runtime works).</li>
<li>the second cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2, 3]</code> and the
outer <code>a</code> to <code>[1, 2]</code></li>
<li>the third cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2]</code></li>
<li>the 4th cycle we add 1 to <code>sum</code> and set <code>a</code> to <code>[]</code></li>
<li>the 5th cycle we update our return value with <code>sum</code>, which is now 4</li>
</ul>
<p>We can only fix this be understanding that we're programming a graph. I tried to
make Graphix as much like a normal language as possible, but this is where we
depart from that possibility. The general idea is, we need to queue updates to
the outer <code>a</code> until we're done processing the current one. For that we have a
builtin called <code>queue</code>, here is the correct implementation</p>
<pre><code class="language-graphix">let len = |a: Array&lt;'a&gt;| {
  let clock = once(null);
  let q = queue(#clock, a);
  let sum = 0;
  select q {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      q &lt;- tl
    },
    _ =&gt; {
      clock &lt;- null;
      sum &lt;- 0;
      once(sum)
    }
  }
}
</code></pre>
<p>Every time <code>clock</code> updates <code>queue</code> will output something it has queued, or if it
has nothing queued it will store that the next thing that arrives can go out
immediatly. So the first <code>a</code> will immediatly pass through the queue, but
anything after that will be held. Then the normal select loop will run, except
it will look at <code>q</code> instead of <code>a</code> now, so that <code>a</code> can update without
disturbing it. When we get to the terminating case, we update for next cycle
<code>clock</code> with <code>null</code> and <code>sum</code> with 0 and we return <code>once(sum)</code>. We return
<code>once(sum)</code> instead of just <code>sum</code> because removing something from the queue
takes one cycle, so it will be two cycles before we start on the next array, and
in the mean time the existing array will still be empty, meaning the second
select arm will still be selected, and <code>sum</code> is updating to 0 which we do not
want to return. If we run this with the same set of examples we will get the
correct answer,</p>
<pre><code>$ graphix cycle_iter.gx
5
3
2
</code></pre>
<p>This comes up other places as well, for example whenever we have to
deal with something that does IO, like calling an RPC, subscribing to
values in netidx, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<p>You can define your own data types in Graphix. This is useful for many tasks,
such as enforcing interface invariants, and modeling data. As a data modeling
language Graphix supports both structures, so called conjunctive types, where
you are modeling data that always appears together, and variants, or so called
disjunctive types, where a type can be one of many possible types drawn from a
set. This contrasts with other languages, for example Python, which only support
conjunctive types.</p>
<h2 id="structural-typing"><a class="header" href="#structural-typing">Structural Typing</a></h2>
<p>In most languages types are dealt with by name, meaning that two structs with
exactly the same fields are still different types if they have a different name.
The obvious implication of this is that all types need to be given a name, and
thus declared. Graphix works differently. Types in Graphix are structural,
meaning that types that are structurally the same are the same type. In fact
types in Graphix don't formally have names, there can be aliases for a large
type to cut down on verbosity, but an alias is always resolved to the structural
type when type checking. Because of this you don't need to declare types before
using them.</p>
<h2 id="set-based-type-system"><a class="header" href="#set-based-type-system">Set Based Type System</a></h2>
<p>The Graphix type system is based on set operations. For example, a function
could declare that it can take either an <code>i32</code> or an <code>i64</code> as an argument by
defining the set, <code>[i32, i64]</code> and annotating it's argument with this type.</p>
<pre><code class="language-graphix">let f = |a: [i32, i64]| ...
</code></pre>
<p>When this function is called, the type checker will check that the type of
argument <code>a</code> is a subset of <code>[i32, i64]</code>, and will produce a type error if it is
not. Pretty much every operation the type checker performs in Graphix is one of,
or a combination of, simple set operations contains, union, difference, etc.</p>
<p>The combination of structural typing, set based type operations, and aggressive
type inference is meant to make Graphix feel like an untyped scripting language
most of the time, but still catch a lot of mistakes at compile time, and make it
possible to enforce interface contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs allow you to define a type that groups any number of fields together as
one data object. The fields are accessible by name anywhere in the program. For
example,</p>
<pre><code class="language-graphix">{ foo: string, bar: i64 }
</code></pre>
<p>defines a struct with two fields, <code>foo</code> and <code>bar</code>. <code>foo</code> has type <code>string</code> and
<code>bar</code> has type <code>i64</code>. We can assign a struct of this type to a variable, and
pass it around just like any other data object. For example,</p>
<pre><code class="language-graphix">let s = { foo: "I am foo", bar: 42 }
println("the struct s is [s]")
</code></pre>
<p>will print</p>
<pre><code>the struct s is {bar: 42, foo: "I am foo"}
</code></pre>
<h2 id="field-references"><a class="header" href="#field-references">Field References</a></h2>
<p>Struct fields can be referenced with the .field notation. That is,</p>
<pre><code class="language-graphix">〉s.foo
-: string
"I am foo"
</code></pre>
<p>A more complex expression that results in a struct (such as a function call),
must be placed in parenthesis before the .field. For example,</p>
<pre><code class="language-graphix">〉let f = || s
〉(f()).foo
-: string
"I am foo"
</code></pre>
<h2 id="mutability-and-functional-update"><a class="header" href="#mutability-and-functional-update">Mutability and Functional Update</a></h2>
<p>Structs are not mutable, like everything else in Graphix. However There is a
quick way create a new struct from an existing struct with only some fields
changed. This is called functional struct update syntax. For example,</p>
<pre><code class="language-graphix">{ s with bar: 21 }
</code></pre>
<p>Will create a new struct with all the same fields as <code>s</code> except <code>bar</code> which will be set to 21. e.g.</p>
<pre><code class="language-graphix">〉{ s with bar: 21 }
-: {bar: i64, foo: string}
{bar: 21, foo: "I am foo"}
</code></pre>
<p>Notice that the type printed is the full type of the struct, this is because of structural typing.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Structs are implemented as a sorted array of pairs, the field name being the
first element of the pair, and the data value being the second. The array is
sorted by the field name, and because of this it is not necessary to do any
matching when the field is accessed at run time, the index of the field
reference is pre computed at compile time, so field references are always O(1).
The reason why the fields are stored at all is so they can be used on the
network and in files without losing information. Because structs are array
backed, they are also memory pooled, and so making a new struct does not usually
allocate any memory, but instead reuses objects from the pool.</p>
<p>The <code>cast</code> operator can cast an unsorted array of pairs where the first element
is a string to a struct type. For example,</p>
<pre><code class="language-graphix">〉cast&lt;{foo: string, bar: i64}&gt;([["foo", "I am foo"], ["bar", 42]])$
-: {bar: i64, foo: string}
{bar: 42, foo: "I am foo"}
</code></pre>
<p>Structs along with <code>cast</code> can be used to communicate complex values over the
network as long as the two sides agree on what the type is supposed to be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants"><a class="header" href="#variants">Variants</a></h1>
<p>Variants allow you to define a case that belongs to a set of possible cases a
value is allowed to be. For example we might categorize foods,</p>
<pre><code>[`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]
</code></pre>
<p>Here we've defined a set of variants that together cover all the cases we want
to model. We can write a function that will only accept a member of this set,</p>
<pre><code>let f = |food: [`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]| ...
</code></pre>
<p>and the type checker will ensure that it is an error caught at compile time to
pass any other type of value to this function. The most interesting variant in this set is probably</p>
<pre><code>`Other(string)
</code></pre>
<p>Because it carries data with it. Variant cases can carry an zero or more values
with them (types separated by commas, e.g. `Other(string, i64)). We can use
pattern matching to extract these values at run time. Lets write the body of our
food consuming function,</p>
<pre><code>let f = |food: [`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]| select food {
  `Vegetable =&gt; "it's a vegetable",
  `Fruit =&gt; "it's a fruit",
  `Meat =&gt; "it's meat",
  `Grain =&gt; "it's grain",
  `Other(s) =&gt; "it's a [s]"
};
f(`Other("foo"))
</code></pre>
<p>If we copy the above into a file and run it we will get,</p>
<pre><code>$ graphix test.gx
"it's a foo"
</code></pre>
<p>In this example the type checker will ensure that,</p>
<ul>
<li>every item in the set is matched by a non guarded arm of the select (see the section on select)</li>
<li>no extra items that can't exist in the set are matched</li>
<li>you can't pass anything to f that isn't in the set</li>
</ul>
<p>Singleton variant cases like `Other(string) are actually a perfectly valid type
in Graphix, although they are much more useful in sets. Once we start naming
types (in a later section), they will become even more useful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h1>
<p>Tuples are like structs where the field names are numbers, or like Arrays where
every element can be a different type and the length is known at compile time. For example,</p>
<pre><code class="language-graphix">(string, i64, f64)
</code></pre>
<p>Is an example of a three tuple.</p>
<h2 id="field-accessors"><a class="header" href="#field-accessors">Field Accessors</a></h2>
<p>You can access the fields of a tuple by their field number, e.g. .0, .1, .2, etc.</p>
<pre><code class="language-graphix">〉let t = (1, 2, 3)
〉t.0 == 1
-: bool
true
</code></pre>
<p>Tuple fields may also be bound in a pattern match in a let bind, a select arm, or a function argument. For example,</p>
<pre><code class="language-graphix">〉let (f0, f1, f2) = t
〉f0
-: i64
1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-types"><a class="header" href="#named-types">Named Types</a></h1>
<p>You can name types to avoid having to type them more than once. Named types are
just aliases for the full structure of the type they reference. The fully
written out type is the same as the alias and visa versa. Lets go back to our
foods example from the section on variants.</p>
<pre><code>type FoodKind = [
  `Vegetable,
  `Fruit,
  `Meat,
  `Grain,
  `Other(string)
];

let v: FoodKind = `Vegetable;
let f = |food: FoodKind| ...
</code></pre>
<p>Aliases are very useful for more complex types that are used many times.
Selective annotations can also help the type checker make sense of complex
program structures.</p>
<p>In the next section you'll see that we can do a lot more with them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h1>
<p>We can define type variables as part of the definition of named types and then
use them in the type definition in order to create type aliases with type
parameters. For example, suppose in our foods example we wanted to specify that
`Other could carry a value other than a string,</p>
<pre><code>type FoodKind&lt;'a&gt; = [
  `Vegetable,
  `Fruit,
  `Meat,
  `Grain,
  `Other('a)
];
let v: FoodKind&lt;`Cookie&gt; = `Other(`Cookie);
v
</code></pre>
<p>if we paste this program into a file and run it we get,</p>
<pre><code>$ graphix test.gx
`Other(`Cookie)
</code></pre>
<p>We can even place constraints on the type that a type variable can take. For example,</p>
<pre><code>type Point3&lt;'a: Number&gt; = {x: 'a, y: 'a, z: 'a};
let f = |p: Point3&lt;'a&gt;, x: 'a| {p with x: p.x + x};
f({x: 0., y: 1., z: 3.14}, 1.)
</code></pre>
<p>Running this program we get,</p>
<pre><code>$ graphix test.gx
{x: 0, y: 1, z: 3.14}
</code></pre>
<p>However, consider,</p>
<pre><code>type Point3&lt;'a: Number&gt; = {x: 'a, y: 'a, z: 'a};
let v: Point3&lt;'a&gt; = {x: "foo", y: "bar", z: "baz"};
v
</code></pre>
<p>Running this, we can see that <code>'a</code> is indeed constrained, since we get</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    0: at: line: 2, column: 21, in: { x: "foo", y: "bar", z: "baz" }
    1: type mismatch Point3&lt;'a: [Int, Real]&gt; does not contain {x: string, y: string, z: string}
</code></pre>
<p>Indicating that we can't construct a Point3 with the type parameter of <code>string</code>,
because the constraint is violated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<p>Type aliases can be used to define recursive types, and this is a very powerful
modeling tool for repeating structure. If you want to see an advanced example
look no further than the <code>Tui</code> type in <code>graphix-shell</code>. Tui's are a set of
mutually recursive types that define the tree structure of a UI. For a less
overwhelming example consider a classic,</p>
<pre><code class="language-graphix">type List&lt;'a&gt; = [
  `Cons('a, List&lt;'a&gt;),
  `Nil
]
</code></pre>
<p>This defines a singly linked list as a set of two variant cases. Either the list
is empty (nil), or it is a cons cell with a <code>'a</code> and a list, which itself could
be either a cons cell or nil. If you've never heard the term "cons" and "nil"
they come from lisp, the original functional programming language from the late
1950s. Anyway, lets define some functions to work on our new list type,</p>
<pre><code class="language-graphix">type List&lt;'a&gt; = [
  `Cons('a, List&lt;'a&gt;),
  `Nil
];

/// cons a new item on the head of the list
let cons = |l: List&lt;'a&gt;, v: 'a| -&gt; List&lt;'a&gt; `Cons(v, l);

/// compute the length of the list
let len = |l: List&lt;'a&gt;| {
  let rec len_int = |l: List&lt;'a&gt;, n: i64| select l {
    `Cons(_, tl) =&gt; len_int(tl, n + 1),
    `Nil =&gt; n
  };
  len_int(l, 0)
};

/// map f over the list
let rec map = |l: List&lt;'a&gt;, f: fn('a) -&gt; 'b| -&gt; List&lt;'b&gt; select l {
  `Cons(v, tl) =&gt; `Cons(f(v), map(tl, f)),
  `Nil =&gt; `Nil
};

/// fold f over the list
let rec fold = |l: List&lt;'a&gt;, init: 'b, f: fn('b, 'a) -&gt; 'b| -&gt; 'b select l {
  `Cons(v, tl) =&gt; fold(tl, f(init, v), f),
  `Nil =&gt; init
}
</code></pre>
<p>You can probably see where functional programming gets it's (partly deserved)
reputation for being elegant and simple. Lets try them out,</p>
<pre><code class="language-graphix">let l = cons(cons(cons(cons(`Nil, 1), 2), 3), 4);
l
</code></pre>
<p>running this we get,</p>
<pre><code>$ graphix test.gx
`Cons(4, `Cons(3, `Cons(2, `Cons(1, `Nil))))
</code></pre>
<p>Lets try something more complex,</p>
<pre><code class="language-graphix">map(l, |x| x * x)
</code></pre>
<p>results in</p>
<pre><code>$ graphix test.gx
`Cons(16, `Cons(9, `Cons(4, `Cons(1, `Nil))))
</code></pre>
<p>as expected. Finally lets sum the list with fold,</p>
<pre><code class="language-graphix">fold(l, 0, |acc, v| acc + v)
</code></pre>
<p>and as expected we get,</p>
<pre><code>$ graphix test.gx
10
</code></pre>
<p>So with recursive types and recursive functions you can do some really powerful
things. When you add these capabilities to the data flow nature of Graphix, it
only multiplies the power even further.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>A reference value is not the thing itself, but a reference to it, just like a
pointer in C. This is kind of an odd thing to have in a very high level language
like Graphix, but there are good reasons for it. Before we get into those lets
see what one looks like.</p>
<pre><code class="language-graphix">〉let v = &amp;1
〉v
-: &amp;i64
727
</code></pre>
<p>The <code>&amp;</code> in front of the <code>1</code> creates a reference. You can create a reference to
any value. Note that the type isn't <code>i64</code> anymore but <code>&amp;i64</code> indicating that <code>v</code>
is a reference to an <code>i64</code>. Just like a function when printed the reference id
is printed, not the value it refers to. We get the value that this reference 727
refers to with the deref operator *.</p>
<pre><code class="language-graphix">〉*v
-: i64
1
</code></pre>
<h2 id="but-why"><a class="header" href="#but-why">But Why</a></h2>
<p>Now that we've got the basic semantics out of the way, what is this good for?
Suppose we have a large struct, with many fields, or even a struct of structs of
structs with a lot of data. And suppose every time that struct updates we do a
bunch of work. This is exactly how UIs are built by the way, they are deeply
nested tree of structs. Under the normal semantics of Graphix, if any field
anywhere in our large tree of structs were to update, then we'd rebuild the
entire object (or at least a substantial part of it), and any function that
depended on it would have no way of knowing what changed, and thus would have to
do whatever huge amount of work it is supposed to do all over again. Consider a
constrained GUI type with just labels and boxes,</p>
<pre><code class="language-graphix">type Gui = [
  `Label(string),
  `Box(Array&lt;Gui&gt;)
]
</code></pre>
<p>So we can build labels in boxes, and we can nest the boxes, laying out the
labels however we like (use your imagination). We have the same problem as the
more abstract example above, if we were mapping this onto a stateful GUI library
then every time a label text changed anywhere we'd have to destroy all the
widgets we had created and rebuild the entire UI from scratch. We'd like to be
able to just update the label text that changed, and we can, with a small change
to the type.</p>
<pre><code class="language-graphix">type Gui = [
  `Label(&amp;string),
  `Box(Array&lt;Gui&gt;)
]
</code></pre>
<p>Now, the string inside the label is a reference instead of the actual string.
Since references are assigned an id at compile time, they never change, and so
the layout of our GUI can never change just because a label text was updated.
Whatever is actually building the GUI will only see an update to the root when
the actual layout changes. To handle the labels it can just deref the string
reference in each label, and when that updates it can update the text of the
label, exactly what we wanted.</p>
<h2 id="connect-deref"><a class="header" href="#connect-deref">Connect Deref</a></h2>
<p>Suppose we want to write a function that can update the value a passed in
reference refers to, instead of the reference itself (which we can also do). We
can do that with,</p>
<pre><code class="language-graphix">*r &lt;- "new value"
</code></pre>
<p>Consider,</p>
<pre><code class="language-graphix">let f = |x: &amp;i64| *x &lt;- once(*x) + 1;
let v = 0;
f(&amp;v);
println("[v]")
</code></pre>
<p>Running this program will output,</p>
<pre><code>$ graphix test.gx
0
1
</code></pre>
<p>We were able to pass <code>v</code> into <code>f</code> by reference and it was able to update it,
even though the original bind of <code>v</code> isn't even in a scope that <code>f</code> can see.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Graphix has a simple module system, with the minimal required functionality
necessary to organize code into a project.</p>
<p>The module system should be considered a work in progress, more features may be
added in the future. In particular there are a few unfinished parts,</p>
<ul>
<li>no module renaming on use</li>
<li>no access control, everything in a module is currently public</li>
</ul>
<p>These shortcomings may be fixed in a future release. Current features include,</p>
<ul>
<li>module hierarchies</li>
<li>inline modules (defined in the same file)</li>
<li>modules defined in external files</li>
<li>modules defined in netidx</li>
<li>modules dynamically loadable at runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-modules"><a class="header" href="#inline-modules">Inline Modules</a></h1>
<p>In a single file, you can define modules inline. Expressions in modules are semi
colon separated. expressions defined in a module may be referred to directly
e.g. <code>m::name</code> or by bringing the module into scope with <code>use m</code>.</p>
<pre><code class="language-graphix">mod m {
  let hello = "hello world";
  let goodbye = "goodbye world"
};

"we say [m::hello] followed by [m::goodbye]"
</code></pre>
<p>running this we get,</p>
<pre><code>$ graphix test.gx
"we say hello world followed by goodbye world"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-modules"><a class="header" href="#external-modules">External Modules</a></h1>
<p>A simple external module may be defined in either a file or by a value in
netidx. In the case of a file, the file name must end in <code>.gx</code> and the part
before that is the name of the module. For example a file <code>m.gx</code> contains the
expressions defining the module <code>m</code>. Expressions in the file do not need to be
surrounded by a <code>mod m { ... }</code>, the name of the module is taken from the
filename.</p>
<p>In netidx, a string value containing Graphix source is published, and the final
name in the path is the name of the module, no <code>.gx</code> is required for netidx
modules. For example we might publish <code>/libs/graphix/strops</code>, the name of the
module would be <code>strops</code>, and the resolver expects it to be a string containing
valid Graphix code, just like a file.</p>
<p>Here is a simple example with file modules,</p>
<pre><code>$ ls
m.gx  test.gx
</code></pre>
<p><code>test.gx</code> is the program that we will run, <code>m.gx</code> is a module it will load.</p>
<p><code>test.gx</code></p>
<pre><code class="language-graphix">mod m;

m::hello
</code></pre>
<p><code>m.gx</code></p>
<pre><code class="language-graphix">let hello = "hello world"
</code></pre>
<p>running this we get,</p>
<pre><code>$ graphix test.gx
"hello world"
</code></pre>
<h2 id="module-load-path"><a class="header" href="#module-load-path">Module Load Path</a></h2>
<p>The graphix shell reads the <code>GRAPHIX_MODPATH</code> environment variable at startup
and appends it's contents to the built in list of module paths. The syntax is a
comma separated list of paths. Paths that start with <code>netidx:</code> are netidx paths,
otherwise file paths are expected. The comma separator can be escaped with <code>\</code>.
For example,</p>
<pre><code>GRAPHIX_MODPATH=netidx:/foo,/home/user/graphix-modules,/very/str\,ange/path
</code></pre>
<p>would add</p>
<ul>
<li>netidx:/foo</li>
<li>/home/user/graphix-modules</li>
<li>/very/str,ange/path</li>
</ul>
<p>to the Graphix module path</p>
<h3 id="default-module-path"><a class="header" href="#default-module-path">Default Module Path</a></h3>
<p>By default the module resolve path has several entries,</p>
<ul>
<li>
<p>the parent directory of the program file passed on the command line. e.g. if
we are running <code>/home/user/test.gx</code> then Graphix will look for modules in
<code>/home/user</code></p>
</li>
<li>
<p>the Graphix init directory. This is a platform specific directory where you
can put Graphix modules.</p>
<ul>
<li>On Linux <code>~/.local/share/graphix</code></li>
<li>On Windows <code>%APPDATA%\Roaming\graphix</code></li>
<li>On Mac OS <code>~/Library/Application Support/graphix</code></li>
</ul>
</li>
</ul>
<p>In REPL mode, which is when it's given no argument, the <code>graphix</code> command will
try to load the module <code>init</code>. If no such module exists it will silently carry
on. You can use this to load commonly used utilities in the repl automatically.</p>
<h2 id="modules-in-netidx"><a class="header" href="#modules-in-netidx">Modules in Netidx</a></h2>
<p>We can publish the same code as the files example in netidx and use it in
Graphix directly, but we have to run it in a slightly different way, first lets
publish it,</p>
<pre><code>$ printf \
  "/local/graphix/test|string|%s\n/local/graphix/m|string|%s" \
  "$(tr \n ' ' &lt;test.gx)" "$(tr \n ' ' &lt;m.gx)" \
  | netidx publisher
</code></pre>
<p>Graphix doesn't care about whitespaces like newline, so we can just translate
them to spaces to avoid confusing the command line publisher. Lets see if we
published successfully.</p>
<pre><code>$ netidx subscriber /local/graphix/test
/local/graphix/test|string|"mod m;  m::hello"
</code></pre>
<p>Looks good, now lets run the code. In order to do this we need to add to the
resolve path to tell the Graphix shell where it should look for modules. We also
don't pass a <code>.gx</code> extension, so we are telling Graphix to look for a module
named <code>test</code> in it's configured module paths and run that.</p>
<pre><code>$ GRAPHIX_MODPATH=netidx:/local/graphix graphix test
"hello world"
</code></pre>
<h2 id="module-hierarchies"><a class="header" href="#module-hierarchies">Module Hierarchies</a></h2>
<p>Module hierarchies can be created using directories, for example to create
<code>m::n</code> you would create a directory <code>m</code> and in it a file called <code>mod.gx</code> and a
file called <code>n.gx</code></p>
<pre><code>$ find .
.
./m
./m/mod.gx
./m/n.gx
./test.gx
</code></pre>
<p><code>test.gx</code> is the root of the hierarchy</p>
<pre><code class="language-graphix">mod m;

m::n::hello
</code></pre>
<p><code>m/mod.gx</code> is the root of module <code>m</code></p>
<pre><code class="language-graphix">mod n
</code></pre>
<p><code>m/n.gx</code> is the <code>m::n</code> module</p>
<pre><code class="language-graphix">let hello = "hello world"
</code></pre>
<p>if we run the program we get,</p>
<pre><code>$ graphix test.gx
"hello world"
</code></pre>
<h2 id="module-hierarchies-in-netidx"><a class="header" href="#module-hierarchies-in-netidx">Module Hierarchies in Netidx</a></h2>
<p>Module hierarchies in netidx work the same as in the file system except that
<code>mod.gx</code> is never needed because in <code>netidx</code> a value can also be a container. So
to replicate the above example we'd publish,</p>
<pre><code>/lib/graphix/test &lt;- the contents of test.gx
/lib/graphix/m    &lt;- the contents of m/mod.gx
/lib/graphix/m/n  &lt;- the contents of m/n.gx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-modules"><a class="header" href="#dynamic-modules">Dynamic Modules</a></h1>
<p>Graphix programs can dynamically load modules at runtime. The loaded code will
be compiled, type checked, and the loader will return an error indicating any
failure in that process. Because Graphix is a statically typed language we must
know ahead of time what interface the dynamically loaded module will have. We do
this by defining a module signature. We can also define what the dynamically
loaded module is allowed to reference, in order to prevent it from just calling
any function it likes (aka it's sandboxed). Lets dive right in with an example,</p>
<pre><code class="language-graphix">// the module source, which we will publish in netidx
let path = "/local/foo";
let source = "
    let add = |x| x + 1;
    let sub = |x| x - 1;
    let cfg = \[1, 2, 3, 4, 5\];
    let hidden = 42
";
net::publish(path, source)$;

// now load the module
let status = mod foo dynamic {
    sandbox whitelist [core];
    sig {
        val add: fn(i64) -&gt; i64;
        val sub: fn(i64) -&gt; i64;
        val cfg: Array&lt;i64&gt;
    };
    source cast&lt;string&gt;(net::subscribe(path)$)$
};
select status {
    error as e =&gt; never(dbg(e)),
    null as _ =&gt; foo::add(foo::cfg[0]$)
}
</code></pre>
<p>running this we get,</p>
<pre><code>$ graphix test.gx
2
</code></pre>
<p>In the first part of this program we just publish a string containing the source
code of the module we want to ultimately load. The second part is where it gets
interesting, lets break it down.</p>
<p><code>mod foo dynamic</code> declares a dynamically loaded module named <code>foo</code>. In the rest
of our code we can refer (statically) to <code>foo</code> as if it was a normal module that
we loaded at compile time. There are three sections required to define a dynamic
module, they are required to be defined in order, sandbox, sig, and source,</p>
<ul>
<li>a <code>sandbox</code> statement, of which there are three types
<ul>
<li><code>sandbox unrestricted;</code> no sandboxing, the dynamic module can access
anything in it's scope</li>
<li><code>sandbox whitelist [item0, item1, ...]</code> the dynamic module may access ONLY
the names explicitly listed. e.g. <code>sandbox whitelist [core::array];</code> would
allow the dynamic module to access only <code>core::array</code> and nothing else.</li>
<li><code>sandbox blacklist [item0, item1, ...]</code> the dynamic module may access
anything except the names listed. <code>sandbox blacklist [super::secret::module];</code> everything except super secret module would be
accessible</li>
</ul>
</li>
<li>a <code>sig</code> statement is the type signature of the module. This is a special
syntax for writing module type signatures. There are three possible statements,
<ul>
<li>a val statement defines a value and it's type, <code>val add: fn(i64) -&gt; i64</code> is
an example of a val statement, it need not be a function it can be any type</li>
<li>a type statement defines a type in the loaded module, e.g. <code>type T = { foo: string, bar: string }</code> val statements that come after a type statement may
use the defined type. The type statement is identical to the normal type
statement in Graphix (so it can be polymorphic, recursive, etc).</li>
<li>a mod statement defines a sub module of the dynamically loaded module. A sub
module must have a sig. <code>mod m: sig { ... }</code> defines a sub module.</li>
</ul>
</li>
<li>a <code>source</code> statement defines where the source code for the dynamic module will
come from. It's type must be a string.</li>
</ul>
<p>The <code>mod foo dynamic ...</code> expression returns a value of type,</p>
<p><code>[null, Error&lt;`DynamicLoadError(string)&gt;]</code></p>
<p>The runtime will try to load the module every time the source updates. If it
succeeds it will update with <code>null</code>, if it fails it will update with an error
indicating what went wrong. Regardless of the outcome the previous loaded
module, if any, will be deleted. If compilation succeeded the new module will be
initialized, possibly causing values it exports to update.</p>
<p>Obviously the loaded module must match the type signature defined in the dynamic
mod statement. However, the signature checking only cares that every item
mentioned in the signature is present in the dynamic module and that the types
match. If extra items are present in the dynamic module they will simply be
ignored, and will be inaccessible to the loading program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-graphix-shell"><a class="header" href="#the-graphix-shell">The Graphix Shell</a></h1>
<p>The Graphix shell (<code>graphix</code>) is the primary way to interact with Graphix programs. It provides both an interactive REPL for experimentation and a runtime for executing Graphix scripts. This chapter explores the shell's behavior in depth, covering topics like output handling, module resolution, and project structure.</p>
<h2 id="running-modes"><a class="header" href="#running-modes">Running Modes</a></h2>
<p>The shell operates in several distinct modes:</p>
<h3 id="repl-mode"><a class="header" href="#repl-mode">REPL Mode</a></h3>
<p>When you run <code>graphix</code> with no arguments, it starts an interactive Read-Eval-Print Loop:</p>
<pre><code class="language-bash">graphix
</code></pre>
<p>In REPL mode:</p>
<ul>
<li>Input is read line by line from the user</li>
<li>Each line is compiled and executed immediately</li>
<li>Completion is available via the Tab key</li>
<li>The value and type of output expressions are
<ul>
<li>built into TUIs if they are of type Tui</li>
<li>printed to stdout if they are not</li>
</ul>
</li>
<li><code>Ctrl+C</code> cancels the currently running expression/tui</li>
<li><code>Ctrl+D</code> exits the shell</li>
</ul>
<p>REPL mode is designed for interactive exploration. It doesn't enable warnings by default to keep the experience lightweight.</p>
<h3 id="script-mode"><a class="header" href="#script-mode">Script Mode</a></h3>
<p>When you pass a file path, directory path, or netidx url to <code>graphix</code>, it runs in script mode:</p>
<pre><code class="language-bash">graphix ./myprogram.gx
graphix ./myapp # my app is a directory containing a main.gx
graphix netidx:/path/to/my/program
</code></pre>
<p>In script mode:</p>
<ul>
<li>The entire program source is loaded, compiled, and executed</li>
<li>The value of the last expression is
<ul>
<li>built into a TUI if it is of type Tui</li>
<li>printed to stdout as it updates if it is not</li>
</ul>
</li>
<li><code>Ctrl+C</code> exits the program</li>
<li>Warnings are enabled by default (unused variables, unhandled errors)</li>
</ul>
<p>Script mode is for running complete programs. The shell stays running to
handle the reactive graph's ongoing updates.</p>
<h3 id="check-mode"><a class="header" href="#check-mode">Check Mode</a></h3>
<p>Check mode compiles a program but doesn't execute it:</p>
<pre><code class="language-bash">graphix --check ./myprogram
</code></pre>
<p>You can pass the same program sources to check mode as you can to file
mode.</p>
<p>This is useful for:</p>
<ul>
<li>Verifying syntax and types without running side effects</li>
<li>Integrating with editors and build tools</li>
<li>Quick validation during development</li>
</ul>
<h2 id="understanding-output"><a class="header" href="#understanding-output">Understanding Output</a></h2>
<p>One of the most important concepts to understand about the shell is its output behavior. Not all expressions produce output, and expressions that do produce output can update multiple times.</p>
<h3 id="output-vs-non-output-expressions"><a class="header" href="#output-vs-non-output-expressions">Output vs Non-Output Expressions</a></h3>
<p>The shell only prints values from expressions that are considered "output expressions." The following expression types are <strong>not</strong> considered output and will not print anything:</p>
<ul>
<li><strong>Bindings</strong>: <code>let x = 42</code> defines a variable but doesn't output</li>
<li><strong>Lambdas</strong>: <code>|x| x + 1</code> defines a function but doesn't output</li>
<li><strong>Use statements</strong>: <code>use stdlib::time</code> imports a module but doesn't output</li>
<li><strong>Connect operations</strong>: <code>x &lt;- y</code> schedules updates but doesn't output</li>
<li><strong>Module definitions</strong>: <code>mod m { ... }</code> defines a module but doesn't output</li>
<li><strong>Type definitions</strong>: <code>type Point = {x: f64, y: f64}</code> defines a type but doesn't output</li>
</ul>
<p>Everything else <strong>is</strong> considered an output expression:</p>
<ul>
<li>Values: <code>42</code>, <code>"hello"</code>, <code>true</code></li>
<li>Arithmetic: <code>2 + 2</code></li>
<li>Function calls: <code>time::now()</code></li>
<li>Variable references: <code>x</code></li>
<li>Struct/variant/tuple construction: <code>{x: 10, y: 20}</code></li>
<li>Blocks with output expressions as their last value</li>
</ul>
<p>This is why you can type <code>let x = 42</code> in the REPL and not see any output - it's a binding, not an output expression.</p>
<h3 id="why-programs-keep-running"><a class="header" href="#why-programs-keep-running">Why Programs Keep Running</a></h3>
<p>Graphix programs are reactive dataflow graphs. When you run an expression that produces output, that output can update over time as upstream values change. The shell keeps the program running to display these updates.</p>
<p>For example:</p>
<pre><code class="language-graphix">let count = 0;
let timer = time::timer(duration:1.s, true);
count &lt;- timer ~ (count + 1);
count
</code></pre>
<p>The last line <code>count</code> is an output expression. Its value changes every second as the timer fires. The shell stays running, printing each new value.</p>
<p>To stop watching the output and return to the REPL prompt, press <code>Ctrl+C</code>. In file mode, <code>Ctrl+C</code> exits the entire program.</p>
<h3 id="non-terminating-expressions"><a class="header" href="#non-terminating-expressions">Non-Terminating Expressions</a></h3>
<p>Most useful Graphix programs don't terminate naturally because they're reactive systems responding to events. The program runs until you explicitly stop it with <code>Ctrl+C</code>.</p>
<p>However, some expressions produce a single value and effectively "complete":</p>
<pre><code class="language-graphix">〉2 + 2
-: i64
4
</code></pre>
<p>Even though this printed its value immediately, the shell is still waiting for potential updates. Since <code>2 + 2</code> can never update, nothing more will happen, but you still need <code>Ctrl+C</code> to return to the prompt.</p>
<h3 id="script-output-behavior"><a class="header" href="#script-output-behavior">Script Output Behavior</a></h3>
<p>When you run in script mode only the <strong>last top-level expression</strong> produces output. Consider this file:</p>
<pre><code class="language-graphix">let x = 10
let y = 20
x + y
print("Hello")
x * y
</code></pre>
<p>This file has multiple top-level expressions. The first two are
bindings (no output). The third (<code>x + y</code>) is an output expression but
not the last. The fourth calls <code>print</code> which has side effects but
returns <code>_</code> (bottom). The fifth and final expression (<code>x * y</code>) is the
output expression that the shell will print.</p>
<p>When you run this file:</p>
<ul>
<li><code>print("Hello")</code> will print "Hello" as a side effect</li>
<li>The shell will print the value of <code>x * y</code> (200) as the program output</li>
</ul>
<h3 id="special-output-tuis"><a class="header" href="#special-output-tuis">Special Output TUIs</a></h3>
<p>When the type of the output expression is a Tui then instead of
printing the expression to stdout the Graphix shell will switch to TUI
mode and will render the output expression as a tui. For example,</p>
<pre><code class="language-graphix">〉let count = 0
〉count &lt;- time::timer(1, true) ~ count + 1
〉tui::text::text(&amp;"count is [count]")
</code></pre>
<p>won't print the expression returned by <code>tui::text::text(&amp;"count is [count]")</code> to stdout, it will build a tui,</p>
<p><img src="ui/tui/media/tui_output_example.gif" alt="TUI Output" /></p>
<p>When you type <code>Ctrl+C</code> the shell will exit TUI mode and return to the
normal shell mode. You can use this behavior to experiment with TUI
widgets interactively.</p>
<h2 id="module-resolution"><a class="header" href="#module-resolution">Module Resolution</a></h2>
<p>A crucial feature of the shell is its automatic module path configuration. Understanding how this works is essential for organizing larger projects.</p>
<h3 id="running-a-local-file"><a class="header" href="#running-a-local-file">Running a Local File</a></h3>
<p>When you run a local file, the <strong>parent directory of that file</strong> is automatically added to the module search path:</p>
<pre><code class="language-bash">graphix /home/user/myproject/src/main.gx
</code></pre>
<p>This automatically adds <code>/home/user/myproject/src</code> to the module path. Any <code>.gx</code> files in that directory can be loaded as modules.</p>
<p>For example, if you have:</p>
<pre><code>/home/user/myproject/src/
  main.gx
  utils.gx
  math.gx
</code></pre>
<p>Then <code>main.gx</code> can use:</p>
<pre><code class="language-graphix">mod utils;
mod math;

utils::helper()
</code></pre>
<p>The shell will find <code>utils.gx</code> and <code>math.gx</code> because they're in the same directory.</p>
<h3 id="running-a-local-directory"><a class="header" href="#running-a-local-directory">Running a Local Directory</a></h3>
<p>When you run a local directory, the directory is added to the module
search path. So for example with the same structure as the above files
example you could have executed:</p>
<pre><code class="language-bash">graphix /home/user/myproject/src
</code></pre>
<p>and the result would have been the same.</p>
<h3 id="running-from-netidx"><a class="header" href="#running-from-netidx">Running from Netidx</a></h3>
<p>When you run a program from netidx, the <strong>netidx path</strong> is added to the module search path.</p>
<p>If you run:</p>
<pre><code class="language-bash">graphix netidx:/my/graphix/modules/myprogram
</code></pre>
<p>The shell:</p>
<ol>
<li>subscribes to <code>/my/graphix/modules/myprogram</code></li>
<li>Loads and executes it</li>
<li>Adds <code>netidx:/my/graphix/modules/myprogram</code> to the module search path</li>
</ol>
<p>So if <code>myprogram</code> contains <code>mod utils</code>, the shell will look for
<code>netidx:/my/graphix/modules/myprogram/utils</code>.</p>
<h3 id="module-search-path-priority"><a class="header" href="#module-search-path-priority">Module Search Path Priority</a></h3>
<p>The complete module search path, in order of priority:</p>
<ol>
<li><strong>File parent directory</strong> (if running a local file)</li>
<li><strong>Netidx path</strong> (if running from netidx)</li>
<li><strong>GRAPHIX_MODPATH</strong> entries (from the environment variable)</li>
<li><strong>Platform-specific init directory</strong>:
<ul>
<li>Linux: <code>~/.local/share/graphix</code></li>
<li>Windows: <code>%APPDATA%\Roaming\graphix</code></li>
<li>macOS: <code>~/Library/Application Support/graphix</code></li>
</ul>
</li>
</ol>
<p>The shell searches these paths in order, returning the first match found.</p>
<h3 id="the-graphix_modpath-environment-variable"><a class="header" href="#the-graphix_modpath-environment-variable">The GRAPHIX_MODPATH Environment Variable</a></h3>
<p>You can extend the module search path by setting <code>GRAPHIX_MODPATH</code>:</p>
<pre><code class="language-bash">export GRAPHIX_MODPATH=netidx:/shared/modules,/home/user/graphix-lib
graphix myprogram.gx
</code></pre>
<p>The syntax is a comma-separated list of paths:</p>
<ul>
<li>Paths starting with <code>netidx:</code> are netidx paths</li>
<li>Other paths are treated as filesystem paths</li>
<li>Escape literal commas in paths with <code>\</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-bash">GRAPHIX_MODPATH=netidx:/foo,/home/user/lib,/path/with\,comma
</code></pre>
<p>This adds:</p>
<ul>
<li><code>netidx:/foo</code></li>
<li><code>/home/user/lib</code></li>
<li><code>/path/with,comma</code></li>
</ul>
<h2 id="structuring-larger-projects"><a class="header" href="#structuring-larger-projects">Structuring Larger Projects</a></h2>
<p>Understanding module resolution makes it straightforward to structure larger projects.</p>
<h3 id="single-directory-projects"><a class="header" href="#single-directory-projects">Single-Directory Projects</a></h3>
<p>For small to medium projects, keep all <code>.gx</code> files in a single directory:</p>
<pre><code>myproject/
  main.gx
  ui.gx
  logic.gx
  utils.gx
</code></pre>
<p>Run with:</p>
<pre><code class="language-bash">graphix myproject/main.gx
</code></pre>
<p>The module resolution will automatically find the other <code>.gx</code> files in <code>myproject/</code>.</p>
<h3 id="hierarchical-projects"><a class="header" href="#hierarchical-projects">Hierarchical Projects</a></h3>
<p>For larger projects, use directory hierarchies:</p>
<pre><code>myproject/
  main.gx
  ui/
    mod.gx
    widgets.gx
    layout.gx
  logic/
    mod.gx
    handlers.gx
    state.gx
</code></pre>
<p>In this structure:</p>
<ul>
<li><code>ui/mod.gx</code> defines the <code>ui</code> module (loads submodules)</li>
<li><code>ui/widgets.gx</code> defines the <code>ui::widgets</code> module</li>
<li><code>logic/mod.gx</code> defines the <code>logic</code> module</li>
<li><code>logic/handlers.gx</code> defines the <code>logic::handlers</code> module</li>
</ul>
<p>From <code>main.gx</code>:</p>
<pre><code class="language-graphix">mod ui;
mod logic;

ui::widgets::button("Click me")
</code></pre>
<p>The shell will:</p>
<ol>
<li>Find <code>ui/mod.gx</code> for the <code>ui</code> module</li>
<li>Find <code>ui/widgets.gx</code> when <code>ui/mod.gx</code> does <code>mod widgets</code></li>
<li>Similarly for the <code>logic</code> hierarchy</li>
</ol>
<h3 id="shared-libraries"><a class="header" href="#shared-libraries">Shared Libraries</a></h3>
<p>To share code across multiple projects, use the init directory or <code>GRAPHIX_MODPATH</code>:</p>
<p><strong>Option 1: Init Directory</strong></p>
<p>Place shared modules in your platform's init directory (e.g., <code>~/.local/share/graphix</code> on Linux):</p>
<pre><code>~/.local/share/graphix/
  common.gx
  mylib.gx
</code></pre>
<p>Any Graphix program can then use:</p>
<pre><code class="language-graphix">mod common;
mod mylib;
</code></pre>
<p><strong>Option 2: GRAPHIX_MODPATH</strong></p>
<p>Keep shared libraries elsewhere and point to them:</p>
<pre><code class="language-bash">export GRAPHIX_MODPATH=/opt/graphix-libs
graphix myproject/main.gx
</code></pre>
<p><strong>Option 3: Netidx</strong></p>
<p>Publish shared modules to netidx for organization-wide sharing:</p>
<pre><code class="language-bash"># Publish the library
netidx publisher /shared/graphix/mylib &lt; mylib.gx

# Use it from any program
GRAPHIX_MODPATH=netidx:/shared/graphix graphix myprogram.gx
</code></pre>
<h3 id="the-init-module"><a class="header" href="#the-init-module">The Init Module</a></h3>
<p>In REPL mode only, the shell automatically tries to load a module named <code>init</code>. If found, it's loaded before the REPL starts. If not found, the shell continues silently.</p>
<p>Create an <code>init.gx</code> file in your init directory to:</p>
<ul>
<li>Define commonly used utilities</li>
<li>Set up default imports</li>
</ul>
<p>Example <code>~/.local/share/graphix/init.gx</code>:</p>
<pre><code class="language-graphix">// Commonly used stdlib modules
use time;
use str;
use array;

// Personal utilities
let debug = |x| { print("DEBUG: [x]"); x };
let clear = || print("\x1b[2J\x1b[H");
</code></pre>
<p>Now these are available immediately in any REPL session.</p>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command-Line Options</a></h2>
<p>The <code>graphix</code> command supports several options for controlling its behavior.</p>
<h3 id="netidx-configuration"><a class="header" href="#netidx-configuration">Netidx Configuration</a></h3>
<pre><code class="language-bash"># Use a specific netidx config file
graphix --config /path/to/netidx.toml myprogram.gx

# Specify the netidx authentication mechanism
graphix --auth krb5 myprogram.gx

# Disable netidx entirely (internal-only mode)
graphix --no-netidx myprogram.gx
</code></pre>
<p>When netidx is disabled, networking functions work only within the same process.</p>
<h3 id="publisher-configuration"><a class="header" href="#publisher-configuration">Publisher Configuration</a></h3>
<pre><code class="language-bash"># Set the publisher bind address
graphix --bind 127.0.0.1:5000 myprogram.gx

# Set a timeout for slow subscribers
graphix --publish-timeout 30 myprogram.gx
</code></pre>
<h3 id="module-resolution-1"><a class="header" href="#module-resolution-1">Module Resolution</a></h3>
<pre><code class="language-bash"># Set timeout for resolving netidx modules (seconds)
graphix --resolve-timeout 10 myprogram.gx

# Skip loading the init module in REPL mode
graphix --no-init
</code></pre>
<h3 id="compiler-warnings"><a class="header" href="#compiler-warnings">Compiler Warnings</a></h3>
<p>Control which warnings are enabled with the <code>-W</code> flag:</p>
<pre><code class="language-bash"># Warn about unhandled error operators (?) - default in file mode
graphix -W unhandled myprogram.gx

# Disable warning about unhandled errors
graphix -W no-unhandled myprogram.gx

# Warn about unhandled arithmetic overflow
graphix -W unhandled-arith myprogram.gx

# Warn about unused variables - default in file mode
graphix -W unused myprogram.gx

# Disable unused variable warnings
graphix -W no-unused myprogram.gx

# Make all warnings into errors
graphix -W error myprogram.gx
</code></pre>
<p>Multiple warning flags can be combined:</p>
<pre><code class="language-bash">graphix -W unused -W unhandled -W error myprogram.gx
</code></pre>
<p>If you specify both a flag and its negation (e.g., <code>unhandled</code> and <code>no-unhandled</code>), the <code>no-</code> variant always wins.</p>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Enable debug logging for troubleshooting:</p>
<pre><code class="language-bash">RUST_LOG=debug graphix --log-dir /tmp/graphix-logs myprogram.gx
</code></pre>
<p>Logs will be written to files in the specified directory.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The Graphix shell is designed around the reactive nature of Graphix programs:</p>
<ul>
<li><strong>Output expressions</strong> produce values that can update over time</li>
<li><strong>Programs keep running</strong> to display ongoing updates</li>
<li><strong>Ctrl+C</strong> stops the current expression (REPL) or exits (file mode)</li>
<li><strong>Module resolution</strong> is automatic based on where you run from</li>
<li><strong>Project structure</strong> can be flat or hierarchical</li>
<li><strong>Shared code</strong> can live in the init directory, GRAPHIX_MODPATH, or netidx</li>
</ul>
<p>Understanding these concepts will help you work efficiently with Graphix, whether you're experimenting in the REPL or building large applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<p>The Graphix standard library is split into several modules with different
functions. The <code>core</code> module is always imported with an implicit use statement.
The modules are documented in the sig format used by dynamic module signatures.</p>
<ul>
<li><code>core</code> fundamental functions and types</li>
<li><code>array</code> functions for manipulating arrays</li>
<li><code>map</code> functions for manipulating maps</li>
<li><code>str</code> functions for manipulating strings</li>
<li><code>re</code> regular expressions</li>
<li><code>rand</code> random number generator</li>
<li><code>time</code> timers and time functions</li>
<li><code>net</code> netidx functions</li>
</ul>
<p>The standard library is a work in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">Core</a></h1>
<pre><code class="language-graphix">mod core: sig {
    type Sint = [ i32, z32, i64, z64 ];
    type Uint = [ u32, v32, u64, v64 ];
    type Int = [ Sint, Uint ];
    type Float = [ f32, f64 ];
    type Real = [ Float, decimal ];
    type Number = [ Int, Real ];
    type NotNull = [Number, string, error, array, datetime, duration];
    type Primitive = [NotNull, null];
    type PrimNoErr = [Number, string, array, datetime, duration, null];
    type Log = [`Trace, `Debug, `Info, `Warn, `Error, `Stdout, `Stderr];
    type Result&lt;'r, 'e&gt; = ['r, Error&lt;'e&gt;];
    type Option&lt;'a&gt; = ['a, null];

    type Pos = {
        line: i32,
        column: i32
    };

    type Source = [
        `File(string),
        `Netidx(string),
        `Internal(string),
        `Unspecified
    ];

    type Ori = {
        parent: [Ori, null],
        source: Source,
        text: string
    };

    type ErrChain&lt;'a&gt; = {
        cause: [ErrChain&lt;'a&gt;, null],
        error: 'a,
        ori: Ori,
        pos: Pos
    };

    /// return the first argument when all arguments are equal, otherwise return nothing
    val all: fn(@args: Any) -&gt; Any;

    /// return true if all arguments are true, otherwise return false
    val and: fn(@args: bool) -&gt; bool;

    /// return the number of times x has updated
    val count: fn(Any) -&gt; i64;

    /// return the first argument divided by all subsequent arguments
    val divide: fn('a, @args:'a) -&gt; 'a;

    /// return e only if e is an error
    val filter_err: fn(Result&lt;'a, 'b&gt;) -&gt; Error&lt;'b&gt;;

    /// return v if f(v) is true, otherwise return nothing
    val filter: fn('a, fn('a) -&gt; bool throws 'e) -&gt; 'a throws 'e;

    /// return true if e is an error
    val is_err: fn(Any) -&gt; bool;

    /// construct an error from the specified string
    val error: fn('a) -&gt; Error&lt;'a&gt;;

    /// return the maximum value of any argument
    val max: fn('a, @args: 'a) -&gt; 'a;

    /// return the mean of the passed in arguments
    val mean: fn([Number, Array&lt;Number&gt;], @args: [Number, Array&lt;Number&gt;]) -&gt; Result&lt;f64, `MeanError(string)&gt;;

    /// return the minimum value of any argument
    val min: fn('a, @args:'a) -&gt; 'a;

    /// return v only once, subsequent updates to v will be ignored
    /// and once will return nothing
    val once: fn('a) -&gt; 'a;

    /// seq will update j - i times, starting at i and ending at j - 1
    val seq: fn(i64, i64) -&gt; Result&lt;i64, `SeqError(string)&gt;;

    /// return true if any argument is true
    val or: fn(@args: bool) -&gt; bool;

    /// return the product of all arguments
    val product: fn(@args: [Number, Array&lt;[Number, Array&lt;Number&gt;]&gt;]) -&gt; Number;

    /// return the sum of all arguments
    val sum: fn(@args: [Number, Array&lt;[Number, Array&lt;Number&gt;]&gt;]) -&gt; Number;

    /// when v updates return v if the new value is different from the previous value,
    /// otherwise return nothing.
    val uniq: fn('a) -&gt; 'a;

    /// when v updates place it's value in an internal fifo queue. when clock updates
    /// return the oldest value from the fifo queue. If clock updates and the queue is
    /// empty, record the number of clock updates, and produce that number of
    /// values from the queue when they are available.
    val queue: fn(#clock:Any, 'a) -&gt; 'a;

    /// hold the most recent value of v internally until clock updates. If v updates
    /// more than once before clock updates, older values of v will be discarded,
    /// only the most recent value will be retained. If clock updates when no v is held
    /// internally, record the number of times it updated, and pass that many v updates
    /// through immediately when they happen.
    val hold: fn(#clock:Any, 'a) -&gt; 'a;

    /// ignore updates to any argument and never return anything
    val never: fn(@args: Any) -&gt; _;

    /// when v updates, return it, but also print it along
    /// with the position of the expression to the specified sink
    val dbg: fn(?#dest:[`Stdout, `Stderr, Log], 'a) -&gt; 'a;

    /// print a log message to stdout, stderr or the specified log level using the rust log
    /// crate. Unlike dbg, log does not also return the value.
    val log: fn(?#dest:Log, 'a) -&gt; _;

    /// print a raw value to stdout, stderr or the specified log level using the rust log
    /// crate. Unlike dbg, log does not also return the value. Does not automatically insert
    /// a newline and does not add the source module/location.
    val print: fn(?#dest:Log, 'a) -&gt; _;

    /// print a raw value to stdout, stderr or the specified log level using the rust log
    /// crate followed by a newline. Unlike dbg, log does not also return the value.
    val println: fn(?#dest:Log, 'a) -&gt; _;

    /// Throttle v so it updates at most every #rate, where rate is a
    /// duration (default 0.5 seconds). Intermediate updates that push v
    /// over the #rate will be discarded. The most recent update will always
    /// be delivered. If the sequence, m0, m1, ..., mN, arrives simultaneously
    /// after a period of silence, first m0 will be delivered, then after the rate
    /// timer expires mN will be delivered, m1, ..., m(N-1) will be discarded.
    val throttle: fn(?#rate:duration, 'a) -&gt; 'a;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">Net</a></h1>
<pre><code class="language-graphix">mod net: sig {
    type Table = { rows: Array&lt;string&gt;, columns: Array&lt;(string, v64)&gt; };
    type ArgSpec = { name: string, doc: string, default: Any };

    /// write the value to the specified path
    val write: fn(string, Any) -&gt; Result&lt;_, `WriteError(string)&gt;;

    /// subscribe to the specified path
    val subscribe: fn(string) -&gt; Result&lt;Primitive, `SubscribeError(string)&gt;;

    /// call the specified rpc
    val call: fn(string, Array&lt;(string, Any)&gt;) -&gt; Result&lt;Primitive, `RpcError(string)&gt;;

    /// Publish an rpc. When the rpc is called f will be called with the arguments
    /// sent by the caller, and whatever f returns will be sent back to the caller.
    /// If f does not return, the caller will hang waiting for a reply.
    val rpc: fn(
        #path:string,
        #doc:string,
        #spec:Array&lt;ArgSpec&gt;,
        #f:fn(Array&lt;(string, Any)&gt;) -&gt; Any throws 'e
    ) -&gt; Result&lt;_, `PublishRpcError(string)&gt; throws 'e;

    /// list paths under the specified path. If #update is specified, then the list will
    /// be refreshed each time clock is triggered. If update is not specified, the list will
    /// be updated each second
    val list: fn(?#update:Any, string) -&gt; Result&lt;Array&lt;string&gt;, `ListError(string)&gt;;

    /// list the table under the specified path. If #update is specified, then the table
    /// will be refreshed each time clock is triggered. If update is not specified, the table
    /// will be updated each second
    val list_table: fn(?#update:Any, string) -&gt; Result&lt;Table, `ListError(string)&gt;;

    /// Publish the specified value at the specified path. Whenever the value updates,
    /// the new value will be sent to subscribers. If #on_write is specified, then if
    /// subscribers write to the value on_write will be called with the written value.
    /// on_write need not return anything.
    val publish: fn(?#on_write:fn(Any) -&gt; _ throws 'e, string, Any) -&gt; Result&lt;_, `PublishError(string)&gt; throws 'e;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<pre><code class="language-graphix">mod array: sig {
    type Direction = [
        `Ascending,
        `Descending
    ];

    /// filter returns a new array containing only elements where f returned true
    val filter: fn(Array&lt;'a&gt;, fn('a) -&gt; bool throws 'e) -&gt; Array&lt;'a&gt; throws 'e;

    /// filter_map returns a new array containing the outputs of f
    /// that were not null
    val filter_map: fn(Array&lt;'a&gt;, fn('a) -&gt; Option&lt;'b&gt; throws 'e) -&gt; Array&lt;'b&gt; throws 'e;

    /// return a new array where each element is the output of f applied to the
    /// corresponding element in a
    val map: fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e;

    /// return a new array where each element is the output of f applied to the
    /// corresponding element in a, except that if f returns an array then it's
    /// elements will be concatenated to the end of the output instead of nesting.
    val flat_map: fn(Array&lt;'a&gt;, fn('a) -&gt; ['b, Array&lt;'b&gt;] throws 'e) -&gt; Array&lt;'b&gt; throws 'e;

    /// return the result of f applied to the init and every element of a in
    /// sequence. f(f(f(init, a[0]), a[1]), ...)
    val fold: fn(Array&lt;'a&gt;, 'b, fn('b, 'a) -&gt; 'b throws 'e) -&gt; 'b throws 'e;

    /// each time v updates group places the value of v in an internal buffer
    /// and calls f with the length of the internal buffer and the value of v.
    /// If f returns true then group returns the internal buffer as an array
    /// otherwise group returns nothing.
    val group: fn('a, fn(i64, 'a) -&gt; bool throws 'e) -&gt; Array&lt;'a&gt; throws 'e;

    /// iter produces an update for every value in the array a. updates are produced
    /// in the order they appear in a.
    val iter: fn(Array&lt;'a&gt;) -&gt; 'a;

    /// iterq produces an update for each value in a, but only when clock updates. If
    /// clock does not update but a does, then iterq will store each a in an internal
    /// fifo queue. If clock updates but a does not, iterq will record the number of
    /// times it was triggered, and will update immediately that many times when a
    /// updates.
    val iterq: fn(#clock:Any, Array&lt;'a&gt;) -&gt; 'a;

    /// returns the length of a
    val len: fn(Array&lt;'a&gt;) -&gt; i64;

    /// returns the concatenation of two or more arrays. O(N) where
    /// N is the size of the final array.
    val concat: fn(Array&lt;'a&gt;, @args: Array&lt;'a&gt;) -&gt; Array&lt;'a&gt;;

    /// return an array with the args added to the end. O(N)
    /// where N is the size of the final array
    val push: fn(Array&lt;'a&gt;, @args: 'a) -&gt; Array&lt;'a&gt;;

    /// return an array with the args added to the front. O(N)
    /// where N is the size of the final array
    val push_front: fn(Array&lt;'a&gt;, @args: 'a) -&gt; Array&lt;'a&gt;;

    /// return an array no larger than #n with the args
    /// added to the back. If pushing the args would cause the
    /// array to become bigger than #n, remove values from the
    /// front. O(N) where N is the window size.
    val window: fn(#n:i64, Array&lt;'a&gt;, @args: 'a) -&gt; Array&lt;'a&gt;;

    /// flatten takes an array with two levels of nesting and produces a flat array
    /// with all the nested elements concatenated together.
    val flatten: fn(Array&lt;Array&lt;'a&gt;&gt;) -&gt; Array&lt;'a&gt;;

    /// applies f to every element in a and returns the first element for which f
    /// returns true, or null if no element returns true
    val find: fn(Array&lt;'a&gt;, fn('a) -&gt; bool throws 'e) -&gt; Option&lt;'a&gt; throws 'e;

    /// applies f to every element in a and returns the first non null output of f
    val find_map: fn(Array&lt;'a&gt;, fn('a) -&gt; Option&lt;'b&gt; throws 'e) -&gt; Option&lt;'b&gt; throws 'e;

    /// return a new copy of a sorted ascending (by default). If numeric is true then
    /// values will be cast to numbers before comparison, resulting in a numeric sort
    /// even if the values are strings.
    val sort: fn(?#dir:Direction, ?#numeric:bool, Array&lt;'a&gt;) -&gt; Array&lt;'a&gt;;

    /// return an array of pairs where the first element is the index in
    /// the array and the second element is the value.
    val enumerate: fn(Array&lt;'a&gt;) -&gt; Array&lt;(i64, 'a)&gt;;

    /// given two arrays, return a single array of pairs where the first
    /// element in the pair is from the first array and the second element in
    /// the pair is from the second array. The final array's length will be the
    /// minimum of the length of the input arrays
    val zip: fn(Array&lt;'a&gt;, Array&lt;'b&gt;) -&gt; Array&lt;('a, 'b)&gt;;

    /// given an array of pairs, return two arrays with the first array
    /// containing all the elements from the first pair element and second
    /// array containing all the elements of the second pair element.
    val unzip: fn(Array&lt;('a, 'b)&gt;) -&gt; (Array&lt;'a&gt;, Array&lt;'b&gt;);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-1"><a class="header" href="#map-1">Map</a></h1>
<pre><code class="language-graphix">mod map: sig {
    /// return a new map where each element is the output of f applied to
    /// the corresponding key value pair in the current map
    val map: fn(Map&lt;'a, 'b&gt;, fn(('a, 'b)) -&gt; ('c, 'd) throws 'e) -&gt; Map&lt;'c, 'd&gt; throws 'e;

    /// return a new map containing only the key-value pairs where f applied to
    /// (key, value) returns true
    val filter: fn(Map&lt;'a, 'b&gt;, fn(('a, 'b)) -&gt; bool throws 'e) -&gt; Map&lt;'a, 'b&gt; throws 'e;

    /// filter_map returns a new map containing the outputs of f
    /// that were not null
    val filter_map: fn(Map&lt;'a, 'b&gt;, fn(('a, 'b)) -&gt; Option&lt;('c, 'd)&gt; throws 'e) -&gt; Map&lt;'c, 'd&gt; throws 'e;

    /// return the result of f applied to the init and every k, v pair of m in
    /// sequence. f(f(f(init, (k0, v0)), (k1, v1)), ...)
    val fold: fn(Map&lt;'a, 'b&gt;, 'c, fn('c, ('a, 'b)) -&gt; 'c throws 'e) -&gt; 'c throws 'e;

    /// return the length of the map
    val len: fn(Map&lt;'a, 'b&gt;) -&gt; i64;

    /// get the value associated with the key k in the map m, or null if not present
    val get: fn(Map&lt;'a, 'b&gt;, 'a) -&gt; Option&lt;'b&gt;;

    /// insert a new value into the map
    val insert: fn(Map&lt;'a, 'b&gt;, 'a, 'b) -&gt; Map&lt;'a, 'b&gt;;

    /// remove the value associated with the specified key from the map
    val remove: fn(Map&lt;'a, 'b&gt;, 'a) -&gt; Map&lt;'a, 'b&gt;;

    /// iter produces an update for every key-value pair in the map m.
    /// updates are produced in the order they appear in m.
    val iter: fn(Map&lt;'a, 'b&gt;) -&gt; ('a, 'b);

    /// iterq produces an update for each value in m, but only when clock updates. If
    /// clock does not update but m does, then iterq will store each m in an internal
    /// fifo queue. If clock updates but m does not, iterq will record the number of
    /// times it was triggered, and will update immediately that many times when m
    /// updates.
    val iterq: fn(#clock:Any, Map&lt;'a, 'b&gt;) -&gt; ('a, 'b);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str">Str</a></h1>
<pre><code class="language-graphix">mod str: sig {
    type Escape = {
        escape: string,
        escape_char: string,
        tr: Array&lt;(string, string)&gt;
    };

    /// the default escaping config escapes \, /, \n, \r, \t, \0, and non printable
    /// characters to Unicode \u{HHHH} format
    val default_escape: Escape = {
        escape: "\\/\n\r\t\0",
        escape_char: "\\",
        tr: [("\n", "n"), ("\r", "r"), ("\t", "t"), ("\0", "0")]
    };

    /// return true if s starts with #pfx, otherwise return false
    val starts_with: fn(#pfx:string, string) -&gt; bool;

    /// return true if s ends with #sfx otherwise return false
    val ends_with: fn(#sfx:string, string) -&gt; bool;

    /// return true if s contains #part, otherwise return false
    val contains: fn(#part:string, string) -&gt; bool;

    /// if s starts with #pfx then return s with #pfx stripped otherwise return null
    val strip_prefix: fn(#pfx:string, string) -&gt; Option&lt;string&gt;;

    /// if s ends with #sfx then return s with #sfx stripped otherwise return null
    val strip_suffix: fn(#sfx:string, string) -&gt; Option&lt;string&gt;;

    /// return s with leading and trailing whitespace removed
    val trim: fn(string) -&gt; string;

    /// return s with leading whitespace removed
    val trim_start: fn(string) -&gt; string;

    /// return s with trailing whitespace removed
    val trim_end: fn(string) -&gt; string;

    /// replace all instances of #pat in s with #rep and return s
    val replace: fn(#pat:string, #rep:string, string) -&gt; string;

    /// return the parent path of s, or null if s does not have a parent path
    val dirname: fn(string) -&gt; Option&lt;string&gt;;

    /// return the leaf path of s, or null if s is not a path. e.g. /foo/bar -&gt; bar
    val basename: fn(string) -&gt; Option&lt;string&gt;;

    /// return a single string with the arguments concatenated and separated by #sep
    val join: fn(#sep:string, @args: [string, Array&lt;string&gt;]) -&gt; string;

    /// concatenate the specified strings into a single string
    val concat: fn(@args: [string, Array&lt;string&gt;]) -&gt; string;

    /// escape all the characters in #to_escape in s with the escape character #escape.
    /// The escape character must appear in #to_escape
    val escape: fn(?#esc:Escape, string) -&gt; Result&lt;string, `StringError(string)&gt;;

    /// unescape all the characters in s escaped by the specified #escape character
    val unescape: fn(?#esc:Escape, string) -&gt; Result&lt;string, `StringError(string)&gt;;

    /// split the string by the specified #pat and return an array of each part
    val split: fn(#pat:string, string) -&gt; Array&lt;string&gt;;

    /// reverse split the string by the specified #pat and return an array of each part
    val rsplit: fn(#pat:string, string) -&gt; Array&lt;string&gt;;

    /// split the string at most #n times by the specified #pat and return an array of
    /// each part
    val splitn: fn(#pat:string, #n:i64, string) -&gt; Result&lt;Array&lt;string&gt;, `StringSplitError(string)&gt;;

    /// reverse split the string at most #n times by the specified #pat and return an array of
    /// each part
    val rsplitn: fn(#pat:string, #n:i64, string) -&gt; Result&lt;Array&lt;string&gt;, `StringSplitError(string)&gt;;

    /// give an escape character #esc, and a #sep character, split the string s into an array
    /// of parts delimited by it's non escaped separator characters.
    val split_escaped: fn(#esc:string, #sep:string, string) -&gt; Result&lt;Array&lt;string&gt;, `SplitEscError(string)&gt;;

    /// give an escape character #esc, and a #sep character, split the string s into an array
    /// of at most #n parts delimited by it's non escaped separator characters.
    val splitn_escaped: fn(#n:i64, #esc:string, #sep:string, string) -&gt; Result&lt;Array&lt;string&gt;, `SplitNEscError(string)&gt;;

    /// split the string once from the beginning by #pat and return a
    /// tuple of strings, or return null if #pat was not found in the string
    val split_once: fn(#pat:string, string) -&gt; Option&lt;(string, string)&gt;;

    /// split the string once from the end by #pat and return a tuple of strings
    /// or return null if #pat was not found in the string
    val rsplit_once: fn(#pat:string, string) -&gt; Option&lt;(string, string)&gt;;

    /// change the string to lowercase
    val to_lower: fn(string) -&gt; string;

    /// change the string to uppercase
    val to_upper: fn(string) -&gt; string;

    /// C style sprintf, implements most C standard format args
    val sprintf: fn(string, @args: Any) -&gt; string;

    /// return the length of the string in bytes
    val len: fn(string) -&gt; i64;

    /// extract a substring of s starting at #start with length #len.
    /// both #start and #len are Unicode character indexes,
    /// not byte indexes. e.g. str::sub(#start:0, #len:2, "💖💖💖")
    /// will return "💖💖"
    val sub: fn(#start:i64, #len:i64, string) -&gt; Result&lt;string, `SubError(string)&gt;;

    /// parse the specified string as a value. return the value on success or an
    /// error on failure. Note, if you feed the parser a well formed error then
    /// parse will also return an error
    val parse: fn(string) -&gt; Result&lt;PrimNoErr, `ParseError(string)&gt;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re"><a class="header" href="#re">Re</a></h1>
<pre><code class="language-graphix">mod re: sig {
    /// return true if the string is matched by #pat, otherwise return false.
    /// return an error if #pat is invalid.
    val is_match: fn(#pat:string, string) -&gt; Result&lt;bool, `ReError(string)&gt;;

    /// return an array of instances of #pat in s. return an error if #pat is
    /// invalid.
    val find: fn(#pat:string, string) -&gt; Result&lt;Array&lt;string&gt;, `ReError(string)&gt;;

    /// return an array of captures matched by #pat. The array will have an element for each
    /// capture, regardless of whether it matched or not. If it did not match the corresponding
    /// element will be null. Return an error if #pat is invalid.
    val captures: fn(#pat:string, string) -&gt; Result&lt;Array&lt;Array&lt;Option&lt;string&gt;&gt;&gt;, `ReError(string)&gt;;

    /// return an array of strings split by #pat. return an error if #pat is invalid.
    val split: fn(#pat:string, string) -&gt; Result&lt;Array&lt;string&gt;, `ReError(string)&gt;;

    /// split the string by #pat at most #limit times and return an array of the parts.
    /// return an error if #pat is invalid
    val splitn: fn(#pat:string, #limit:i64, string) -&gt; Result&lt;Array&lt;string&gt;, `ReError(string)&gt;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">Time</a></h1>
<pre><code class="language-graphix">mod time: sig {
    /// When v updates wait timeout and then return it. If v updates again
    /// before timeout expires, reset the timeout and continue waiting.
    val after_idle: fn([duration, Number], 'a) -&gt; 'a;

    /// timer will wait timeout and then update with the current time.
    /// If repeat is true, it will do this forever. If repeat is a number n,
    /// it will do this n times and then stop. If repeat is false, it will do
    /// this once.
    val timer: fn([duration, Number], [bool, Number]) -&gt; Result&lt;datetime, `TimerError(string)&gt;;

    /// return the current time each time trigger updates
    val now: fn(Any) -&gt; datetime;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand"><a class="header" href="#rand">Rand</a></h1>
<pre><code class="language-graphix">mod rand: sig {
    /// generate a random number between #start and #end (exclusive)
    /// every time #clock updates. If start and end are not specified,
    /// they default to 0.0 and 1.0
    val rand: fn&lt;'a: [Int, Float]&gt;(?#start:'a, ?#end:'a, #clock:Any) -&gt; 'a;

    /// pick a random element from the array and return it. Update
    /// each time the array updates. If the array is empty return
    /// nothing.
    val pick: fn(Array&lt;'a&gt;) -&gt; 'a;

    /// return a shuffled copy of a
    val shuffle: fn(Array&lt;'a&gt;) -&gt; Array&lt;'a&gt;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-uis-with-graphix"><a class="header" href="#building-uis-with-graphix">Building UIs With Graphix</a></h1>
<p>Graphix excels at building user interfaces thanks to its reactive dataflow nature. Changes in data automatically propagate through the UI graph, updating only the components that need to change. This makes building complex, interactive applications surprisingly straightforward.</p>
<h2 id="why-graphix-for-uis"><a class="header" href="#why-graphix-for-uis">Why Graphix for UIs?</a></h2>
<p>Traditional UI frameworks require you to manually manage state changes, update DOM elements, and coordinate between different parts of your application. Graphix eliminates this complexity by treating your entire application as a reactive graph where:</p>
<ul>
<li><strong>Data flows automatically</strong>: When underlying data changes, dependent UI components update automatically</li>
<li><strong>State is declarative</strong>: You describe what the UI should look like, not how to update it</li>
<li><strong>Composition is natural</strong>: Complex UIs are built by composing simple, reusable components</li>
<li><strong>Performance is built-in</strong>: Only components that depend on changed data will re-render</li>
</ul>
<h2 id="currently-targeting-tuis"><a class="header" href="#currently-targeting-tuis">Currently Targeting TUIs</a></h2>
<p>The first UI target for Graphix is TUIs. Surprisingly complex and useful UIs can be built in the standard terminal, and it is the absolute lowest common denominator that will always be present even on a bandwidth constrained remote system. Graphix uses the excellent ratatui library as a basis to build upon.</p>
<h2 id="future-ui-targets"><a class="header" href="#future-ui-targets">Future UI Targets</a></h2>
<p>While Graphix currently implements support for building TUIs, the reactive architecture makes it well-suited for other UI paradigms:</p>
<ul>
<li><strong>Desktop Applications</strong>: Native desktop applications. Support for this is planned next.</li>
<li><strong>Web UIs</strong>: The dataflow model maps naturally to modern web frameworks</li>
<li><strong>Mobile UIs</strong>: Touch-based interfaces with gesture handling</li>
</ul>
<p>The core concepts of reactive data flow, component composition, and declarative styling will apply across all UI targets.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The Graphix shell will automatically build a UI if the last value in your module has type <code>tui::Widget</code> (or in the future <code>gui::Widget</code>). You can try out the examples in this book by pasting them in a file, or even typing (the short ones) into the interactive REPL. Each TUI component has detailed documentation in the following sections, including complete API references and practical examples.</p>
<p>You can also study and run the examples in <code>graphix-shell/examples/</code>. Start with simple components like <code>text.gx</code> and <code>block.gx</code>, then work your way up to more complex examples like <code>browser.gx</code> and <code>table-advanced.gx</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-user-interfaces-tuis"><a class="header" href="#terminal-user-interfaces-tuis">Terminal User Interfaces (TUIs)</a></h1>
<p>Graphix includes a comprehensive TUI library built on top of the popular Rust <code>ratatui</code> crate. This allows you to build rich, interactive terminal applications with:</p>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<p>The TUI library provides all the essential building blocks:</p>
<ul>
<li><strong>Layout</strong>: Flexible container system with horizontal/vertical arrangement and various sizing constraints</li>
<li><strong>Block</strong>: Wrapper component that adds borders, titles, and styling to other components</li>
<li><strong>Text</strong>: Rich text rendering with styling, colors, and formatting</li>
<li><strong>Paragraph</strong>: Multi-line text with scrolling and word wrapping</li>
</ul>
<h3 id="interactive-widgets"><a class="header" href="#interactive-widgets">Interactive Widgets</a></h3>
<ul>
<li><strong>Table</strong>: Sortable, selectable data tables with custom styling</li>
<li><strong>List</strong>: Scrollable lists with selection and highlighting</li>
<li><strong>Tabs</strong>: Tabbed interface for organizing content</li>
<li><strong>Browser</strong>: Netidx browser component</li>
<li><strong>Calendar</strong>: Date picker and event display</li>
</ul>
<h3 id="data-visualization"><a class="header" href="#data-visualization">Data Visualization</a></h3>
<ul>
<li><strong>Chart</strong>: Line charts with multiple datasets, custom axes, and styling</li>
<li><strong>Bar Chart</strong>: Grouped and individual bar charts with labels</li>
<li><strong>Sparkline</strong>: Compact inline charts perfect for dashboards</li>
<li><strong>Gauge</strong>: Progress indicators and meters</li>
<li><strong>Canvas</strong>: Low-level drawing surface for custom graphics</li>
</ul>
<h3 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h3>
<p>Interactive components use the input widget to handle UI events that
flow through the widget graph from parent to child. Parents can choose
to pass on events they receive or not. See the input widget for more
details.</p>
<h2 id="building-your-first-tui"><a class="header" href="#building-your-first-tui">Building Your First TUI</a></h2>
<p>Here's a simple example that demonstrates the core concepts:</p>
<pre><code class="language-graphix">use tui;
use tui::block;
use tui::text;
use tui::layout;

let counter = 0;
let clock = time::timer(duration:1.s, true);
counter &lt;- clock ~ (counter + 1);

let content = text(&amp;"Counter: [counter]");

block(
  #border: &amp;`All,
  #title: &amp;line("My First TUI"),
  #style: &amp;style(#fg: `Green),
  &amp;content
)
</code></pre>
<p>This creates a bordered block with a counter that increments every second. The key insight is that when <code>counter</code> changes, the text automatically updates because of Graphix's reactive nature.</p>
<p><img src="ui/tui/./media/overview_first.gif" alt="First Overview" /></p>
<h2 id="styling-and-theming"><a class="header" href="#styling-and-theming">Styling and Theming</a></h2>
<p>Graphix TUIs support rich styling with:</p>
<ul>
<li><strong>Colors</strong>: Named colors (<code>Red</code>, <code>Green</code>, <code>Blue</code>), indexed colors (<code>Indexed(202)</code>), and RGB (<code>Rgb({r: 255, g: 100, b: 50})</code>)</li>
<li><strong>Text Effects</strong>: Bold, italic, underline, strikethrough</li>
<li><strong>Background Colors</strong>: Set background colors for any component</li>
<li><strong>Conditional Styling</strong>: Use <code>select</code> expressions to change styles based on state</li>
</ul>
<p>Many widgets take optional style arguments, allowing styling to be applied at many levels.</p>
<pre><code class="language-graphix">use tui;

let is_selected = true;

style(
  #fg: select is_selected { true =&gt; `Yellow, false =&gt; `White },
  #bg: `DarkGray,
  #add_modifier: [`Bold]
)
</code></pre>
<h2 id="layout-system"><a class="header" href="#layout-system">Layout System</a></h2>
<p>The layout system provides flexible component arrangement:</p>
<ul>
<li><strong>Direction</strong>: <code>Horizontal</code> or <code>Vertical</code></li>
<li><strong>Constraints</strong>: <code>Percentage(50)</code>, <code>Length(20)</code>, <code>Min(10)</code>, <code>Max(100)</code></li>
<li><strong>Alignment</strong>: <code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal; <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical</li>
<li><strong>Focus Management</strong>: Built-in focus handling for interactive components</li>
</ul>
<pre><code class="language-graphix">use tui;
use tui::layout;
use tui::text;

let selected_pane = 0;
let sidebar = text(&amp;"Sidebar");
let main_content = text(&amp;"Main");

layout(
  #direction: &amp;`Horizontal,
  #focused: &amp;selected_pane,
  &amp;[
    child(#constraint: `Percentage(30), sidebar),
    child(#constraint: `Percentage(70), main_content)
  ]
)
</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<p>In Graphix, UI state is just regular program state. Use variables to track:</p>
<ul>
<li>Selection states in lists and tables</li>
<li>Input field contents</li>
<li>Window/pane focus</li>
<li>Application modes (normal, edit, command)</li>
</ul>
<p>State changes automatically trigger UI updates:</p>
<pre><code class="language-graphix">use tui;
use tui::list;
use tui::text;

let selected_item = 0;
let items = [line("Item 1"), line("Item 2"), line("Item 3")];
let arrow_pressed = never();

// When user presses down arrow assume the event is handled as
// shown above and arrow_pressed is set using connect
selected_item &lt;- arrow_pressed ~ ((selected_item + 1) % array::len(items));

// UI automatically reflects the change
list(#selected: &amp;selected_item, &amp;items)
</code></pre>
<h2 id="real-time-data-integration"><a class="header" href="#real-time-data-integration">Real-time Data Integration</a></h2>
<p>Graphix TUIs excel at displaying real-time data. Connect to data sources via netidx and the UI updates automatically:</p>
<pre><code class="language-graphix">use tui;
use tui::gauge;
use tui::text;

// Subscribe to live data
let temperature = cast&lt;f64&gt;(net::subscribe("/sensors/temperature")?)?;

// Will display updates automatically when data changes
gauge(
  #gauge_style: &amp;style(#fg: `Red),
  #label: &amp;span("Temperature"),
  &amp;(temperature / 100.0)
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style"><a class="header" href="#style">style</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bar-chart-widget"><a class="header" href="#the-bar-chart-widget">The Bar Chart Widget</a></h1>
<p>The <code>barchart</code> widget displays categorical data as vertical bars, supporting grouped bars, custom styling, and dynamic updates. It's ideal for comparing values across categories, showing rankings, or displaying resource usage.</p>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<pre><code class="language-graphix">mod barchart: sig {
    /// Creates a bar chart from bar groups
    val bar_chart: fn(
        ?#max: &amp;i64,
        ?#bar_width: &amp;i64,
        ?#bar_gap: &amp;i64,
        ?#group_gap: &amp;i64,
        ?#style: &amp;Style,
        &amp;Array&lt;BarGroup&gt;
    ) -&gt; Widget;

    /// Creates a group of bars
    val bar_group: fn(?#label: Line, Array&lt;Bar&gt;) -&gt; BarGroup;

    /// Creates an individual bar
    val bar: fn(
        ?#style: &amp;Style,
        ?#label: &amp;Line,
        ?#text_value: &amp;Line,
        &amp;i64
    ) -&gt; Bar;
}
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<h3 id="bar_chart"><a class="header" href="#bar_chart">bar_chart</a></h3>
<ul>
<li><strong>max</strong> - Maximum value for chart scale (auto-scales if not specified)</li>
<li><strong>bar_width</strong> - Width of each bar in characters</li>
<li><strong>bar_gap</strong> - Space between bars within a group</li>
<li><strong>group_gap</strong> - Space between bar groups</li>
<li><strong>style</strong> - Base style for the chart</li>
</ul>
<h3 id="bar_group"><a class="header" href="#bar_group">bar_group</a></h3>
<ul>
<li><strong>label</strong> - Line labeling the group (displayed below bars)</li>
</ul>
<h3 id="bar"><a class="header" href="#bar">bar</a></h3>
<ul>
<li><strong>style</strong> - Style for the bar</li>
<li><strong>label</strong> - Line labeling the bar</li>
<li><strong>text_value</strong> - Line displayed above bar (defaults to numeric value)</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::barchart;

let bar1 = bar(
    #style: &amp;style(#fg: `Cyan),
    #label: &amp;line("Sales"),
    &amp;42
);

bar_chart(&amp;[bar_group(#label: line("Q1"), [bar1])])
</code></pre>
<p><img src="ui/tui/./media/barchart_basic.png" alt="Basic Bar Chart" /></p>
<h3 id="grouped-bars-with-dynamic-data"><a class="header" href="#grouped-bars-with-dynamic-data">Grouped Bars with Dynamic Data</a></h3>
<pre><code class="language-graphix">use tui;
use tui::barchart;
use tui::block;
use rand;

let clock = time::timer(duration:0.7s, true);

let group0 = [
    bar(#style: &amp;style(#fg: `Red), #label: &amp;line("CPU"), &amp;rand(#start:0, #end:100, #clock)),
    bar(#style: &amp;style(#fg: `Yellow), #label: &amp;line("Memory"), &amp;rand(#start:25, #end:200, #clock))
];

let group1 = [
    bar(#style: &amp;style(#fg: `Cyan), #label: &amp;line("Network"), &amp;rand(#start:0, #end:50, #clock)),
    bar(#style: &amp;style(#fg: `Magenta), #label: &amp;line("Disk"), &amp;rand(#start:1, #end:25, #clock))
];

let chart = bar_chart(
    #bar_gap: &amp;2,
    #bar_width: &amp;8,
    #max: &amp;200,
    &amp;[
        bar_group(#label: line("Server 1"), group0),
        bar_group(#label: line("Server 2"), group1)
    ]
);

block(#border: &amp;`All, #title: &amp;line("Resource Usage"), &amp;chart)
</code></pre>
<p><img src="ui/tui/./media/barchart_grouped.png" alt="Grouped Bar Chart" /></p>
<h3 id="color-coded-values"><a class="header" href="#color-coded-values">Color-coded Values</a></h3>
<pre><code class="language-graphix">use tui;
use tui::barchart;

let make_colored_bar = |label, value| {
    let color = select value {
        v if v &gt; 80 =&gt; `Red,
        v if v &gt; 50 =&gt; `Yellow,
        _ =&gt; `Green
    };
    bar(#style: &amp;style(#fg: color), #label: &amp;line(label), &amp;value)
};

let bars = [
    make_colored_bar("Service A", 35),
    make_colored_bar("Service B", 65),
    make_colored_bar("Service C", 92)
];

bar_chart(&amp;[bar_group(bars)])
</code></pre>
<p><img src="ui/tui/./media/barchart_colored.png" alt="Colored Bar Chart" /></p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="ui/tui/chart.html">chart</a> - For continuous data visualization</li>
<li><a href="ui/tui/sparkline.html">sparkline</a> - For compact trend display</li>
<li><a href="ui/tui/gauge.html">gauge</a> - For single value display</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-block-widget"><a class="header" href="#the-block-widget">The Block Widget</a></h1>
<p>The <code>block</code> widget is a container that wraps other widgets with optional borders, titles, and styling. It's one of the most commonly used widgets for creating structured layouts and visually separating different sections of your TUI.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<pre><code>mod block: sig {
    type Borders = [`All, `None, `Top, `Bottom, `Left, `Right];

    /// Creates a block widget that wraps content with borders and styling
    val block: fn(
        ?#border: &amp;Borders,
        ?#border_style: &amp;Style,
        ?#title: &amp;Line,
        ?#title_bottom: &amp;Line,
        ?#style: &amp;Style,
        ?#size: &amp;Size,
        &amp;Widget
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><strong>border</strong> - Border style: <code>All</code>, <code>None</code>, <code>Top</code>, <code>Bottom</code>, <code>Left</code>, or <code>Right</code></li>
<li><strong>border_style</strong> - Style for the border</li>
<li><strong>title</strong> - Line displayed at the top of the block</li>
<li><strong>title_bottom</strong> - Line displayed at the bottom of the block</li>
<li><strong>style</strong> - Style for the block's interior</li>
<li><strong>size</strong> (output) - Rendered size of the block</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::block;
use tui::paragraph;

let content = paragraph(&amp;"Hello, World!");

block(
    #border: &amp;`All,
    #title: &amp;line("My Block"),
    &amp;content
)
</code></pre>
<p><img src="ui/tui/./media/block_basic.png" alt="Basic Block" /></p>
<h3 id="focus-indication"><a class="header" href="#focus-indication">Focus Indication</a></h3>
<p>Use dynamic styling to show which block has focus:</p>
<pre><code class="language-graphix">use tui;
use tui::block;
use tui::paragraph;

let focused_block = 0;
let content = paragraph(&amp;"Content here");

block(
    #border: &amp;`All,
    #border_style: &amp;style(
        #fg: select focused_block {
            0 =&gt; `Red,
            _ =&gt; `Yellow
        }
    ),
    #title: &amp;line("Block 1"),
    &amp;content
)
</code></pre>
<p><img src="ui/tui/./media/block_focus.png" alt="Styled Block" /></p>
<h3 id="dynamic-titles"><a class="header" href="#dynamic-titles">Dynamic Titles</a></h3>
<p>Titles can contain reactive values that update automatically:</p>
<pre><code class="language-graphix">use tui;
use tui::block;
use tui::paragraph;

let count = 0;
let timer = time::timer(duration:1.s, true);
count &lt;- timer ~ (count + 1);

let content = paragraph(&amp;"Content here");

block(
    #border: &amp;`All,
    #title: &amp;line("Counter: [count]"),
    &amp;content
)
</code></pre>
<p><img src="ui/tui/./media/block_dynamic_title.png" alt="Block With Dynamic Title" /></p>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="ui/tui/layout.html">layout</a> - For arranging multiple blocks</li>
<li><a href="ui/tui/paragraph.html">paragraph</a> - Common content for blocks</li>
<li><a href="ui/tui/text.html">text</a> - For creating styled text content</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-browser-widget"><a class="header" href="#the-browser-widget">The Browser Widget</a></h1>
<p>The <code>browser</code> widget provides a specialized interface for browsing and interacting with netidx hierarchies. It displays netidx paths in a tree structure with keyboard navigation, selection, and cursor movement support.</p>
<h2 id="apis-1"><a class="header" href="#apis-1">APIs</a></h2>
<pre><code>mod browser: sig {
    type MoveCursor = [`Left(i64), `Right(i64), `Up(i64), `Down(i64)];

    /// Creates a browser widget for navigating netidx hierarchies
    val browser: fn(
        ?#cursor: MoveCursor,
        ?#selected_row: &amp;string,
        #selected_path: &amp;string,
        ?#size: &amp;Size,
        string
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li><strong>cursor</strong> - Programmatic cursor movement: <code>Left(n)</code>, <code>Right(n)</code>, <code>Up(n)</code>, <code>Down(n)</code></li>
<li><strong>selected_row</strong> (output) - Display name of the selected row</li>
<li><strong>selected_path</strong> (output, required) - Full path of the currently selected item</li>
<li><strong>size</strong> (output) - Rendered size of the browser</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::browser;

let selected_path: string = never();

browser(
    #size: {width: 40, height: 10},
    #selected_path: &amp;selected_path,
    "/"  // Start browsing from root
)
</code></pre>
<p><img src="ui/tui/./media/browser_basic.png" alt="Basic Browser Widget" /></p>
<h3 id="basic-navigation"><a class="header" href="#basic-navigation">Basic Navigation</a></h3>
<pre><code class="language-graphix">use tui;
use tui::browser;
use tui::input_handler;

let path = "/";
let selected_path: string = never();
let selected_row: string = never();
let cursor: MoveCursor = never();

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            e@ `Up =&gt; { cursor &lt;- e ~ `Up(1); `Stop },
            e@ `Down =&gt; { cursor &lt;- e ~ `Down(1); `Stop },
            e@ `Left =&gt; { cursor &lt;- e ~ `Left(1); `Stop },
            e@ `Right =&gt; { cursor &lt;- e ~ `Right(1); `Stop },
            e@ `Enter =&gt; { path &lt;- e ~ selected_row; `Stop },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

input_handler(
    #handle: &amp;handle_event,
    &amp;browser(
        #size: {width: 80, height: 24},
        #cursor,
        #selected_path: &amp;selected_path,
        #selected_row: &amp;selected_row,
        path
    )
)
</code></pre>
<p><img src="ui/tui/./media/browser_navigation.gif" alt="Browser With Navigation" /></p>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="ui/tui/list.html">list</a> - For simpler selection interfaces</li>
<li><a href="ui/tui/table.html">table</a> - For tabular data display</li>
<li><a href="ui/tui/block.html">block</a> - For containing browsers with borders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-calendar-widget"><a class="header" href="#the-calendar-widget">The Calendar Widget</a></h1>
<p>The <code>calendar</code> widget displays a monthly calendar view with support for highlighting specific dates and displaying events. It's perfect for date pickers, event schedulers, and time-based visualizations.</p>
<h2 id="apis-2"><a class="header" href="#apis-2">APIs</a></h2>
<pre><code class="language-graphix">mod calendar: sig {
    /// Creates a calendar widget displaying a month
    val calendar: fn(
        ?#show_month: &amp;Style,
        ?#show_weekday: &amp;Style,
        ?#show_surrounding: &amp;Style,
        ?#events: &amp;Array&lt;CalendarEvent&gt;,
        &amp;Date
    ) -&gt; Widget;

    /// Creates an event marker for a specific date
    val calendar_event: fn(Style, Date) -&gt; CalendarEvent;

    /// Creates a date object
    val date: fn(i64, i64, i64) -&gt; Date;  // (year, month, day)
}
</code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<h3 id="calendar"><a class="header" href="#calendar">calendar</a></h3>
<ul>
<li><strong>show_month</strong> - Style for the month header</li>
<li><strong>show_weekday</strong> - Style for weekday headers (Mon, Tue, etc.)</li>
<li><strong>show_surrounding</strong> - Style for dates from surrounding months</li>
<li><strong>events</strong> - Array of CalendarEvent objects to highlight dates</li>
</ul>
<h3 id="calendar_event"><a class="header" href="#calendar_event">calendar_event</a></h3>
<p>Takes a style and a date to create an event marker.</p>
<h3 id="date"><a class="header" href="#date">date</a></h3>
<p>Creates a date with year, month (1-12), and day (1-31).</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::calendar;

let current_date = date(2024, 5, 15);

calendar(&amp;current_date)
</code></pre>
<p><img src="ui/tui/media/calendar_basic.png" alt="Basic Calendar" /></p>
<h3 id="event-calendar"><a class="header" href="#event-calendar">Event Calendar</a></h3>
<pre><code class="language-graphix">use tui;
use tui::calendar;
use tui::block;
use tui::text;

let today = date(2024, 5, 15);

let events = [
    calendar_event(style(#fg: `Red), date(2024, 5, 5)),
    calendar_event(style(#fg: `Green), date(2024, 5, 15)),
    calendar_event(style(#fg: `Yellow), date(2024, 5, 20)),
    calendar_event(style(#fg: `Cyan), date(2024, 5, 28))
];

block(
    #border: &amp;`All,
    #title: &amp;line("May 2024"),
    &amp;calendar(
        #show_month: &amp;style(#fg: `Yellow, #add_modifier: [`Bold]),
        #show_weekday: &amp;style(#fg: `Cyan),
        #show_surrounding: &amp;style(#fg: `DarkGray),
        #events: &amp;events,
        &amp;today
    )
)
</code></pre>
<p><img src="ui/tui/media/calendar_events.png" alt="Calendar With Events" /></p>
<h3 id="color-coded-events-by-type"><a class="header" href="#color-coded-events-by-type">Color-coded Events by Type</a></h3>
<pre><code class="language-graphix">use tui;
use tui::calendar;

type EventType = [`Meeting, `Deadline, `Holiday, `Birthday];
type CalendarEntry = {date: Date, event_type: EventType};

let entries = [
    {date: date(2024, 5, 5), event_type: `Meeting},
    {date: date(2024, 5, 10), event_type: `Deadline},
    {date: date(2024, 5, 15), event_type: `Holiday},
    {date: date(2024, 5, 25), event_type: `Birthday}
];

let event1 = calendar_event(style(#fg: `Blue), date(2024, 5, 5));
let event2 = calendar_event(style(#fg: `Red), date(2024, 5, 10));
let event3 = calendar_event(style(#fg: `Green), date(2024, 5, 15));
let event4 = calendar_event(style(#fg: `Magenta), date(2024, 5, 25));
let events = [event1, event2, event3, event4];

calendar(#events: &amp;events, &amp;date(2024, 5, 1))
</code></pre>
<p><img src="ui/tui/media/calendar_typed.png" alt="Calendar Typed" /></p>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="ui/tui/table.html">table</a> - For tabular date-based data</li>
<li><a href="ui/tui/list.html">list</a> - For event lists</li>
<li><a href="ui/tui/block.html">block</a> - For containing calendars with borders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-canvas-widget"><a class="header" href="#the-canvas-widget">The Canvas Widget</a></h1>
<p>The <code>canvas</code> widget provides a low-level drawing surface for custom graphics. You can draw lines, circles, rectangles, points, and text labels at specific coordinates, making it perfect for diagrams, plots, and custom visualizations.</p>
<h2 id="apis-3"><a class="header" href="#apis-3">APIs</a></h2>
<pre><code>mod canvas: sig {
    type Bounds = {min: f64, max: f64};
    type Shape = [
        `Line({color: Color, x1: f64, y1: f64, x2: f64, y2: f64}),
        `Circle({color: Color, x: f64, y: f64, radius: f64}),
        `Rectangle({color: Color, x: f64, y: f64, width: f64, height: f64}),
        `Points({color: Color, coords: Array&lt;(f64, f64)&gt;}),
        `Label({line: Line, x: f64, y: f64})
    ];

    /// Creates a canvas widget for custom graphics
    val canvas: fn(
        ?#background_color: &amp;Color,
        ?#marker: &amp;Marker,
        #x_bounds: &amp;Bounds,
        #y_bounds: &amp;Bounds,
        &amp;Array&lt;&amp;Shape&gt;
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<ul>
<li><strong>background_color</strong> - Background color for the canvas</li>
<li><strong>marker</strong> - Marker type: <code>Dot</code>, <code>Braille</code> (default), or <code>Block</code></li>
<li><strong>x_bounds</strong> - X-axis range with <code>min</code> and <code>max</code> fields (required)</li>
<li><strong>y_bounds</strong> - Y-axis range with <code>min</code> and <code>max</code> fields (required)</li>
</ul>
<h2 id="shape-types"><a class="header" href="#shape-types">Shape Types</a></h2>
<h3 id="line"><a class="header" href="#line">Line</a></h3>
<pre><code class="language-graphix">`Line({color: `Red, x1: 0.0, y1: 0.0, x2: 10.0, y2: 5.0})
</code></pre>
<h3 id="circle"><a class="header" href="#circle">Circle</a></h3>
<pre><code class="language-graphix">`Circle({color: `Blue, x: 5.0, y: 5.0, radius: 2.0})
</code></pre>
<h3 id="rectangle"><a class="header" href="#rectangle">Rectangle</a></h3>
<pre><code class="language-graphix">`Rectangle({color: `Green, x: 2.0, y: 2.0, width: 3.0, height: 4.0})
</code></pre>
<h3 id="points"><a class="header" href="#points">Points</a></h3>
<pre><code class="language-graphix">`Points({color: `Yellow, coords: [(1.0, 1.0), (2.0, 3.0), (3.0, 1.5)]})
</code></pre>
<h3 id="label"><a class="header" href="#label">Label</a></h3>
<pre><code class="language-graphix">`Label({line: line("Hello"), x: 5.0, y: 0.5})
</code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::canvas;

let line = `Line({color: `Red, x1: 0.0, y1: 0.0, x2: 10.0, y2: 5.0});
let circle = `Circle({color: `Blue, x: 5.0, y: 5.0, radius: 2.0});

canvas(
    #x_bounds: &amp;{min: 0.0, max: 10.0},
    #y_bounds: &amp;{min: 0.0, max: 10.0},
    &amp;[&amp;line, &amp;circle]
)
</code></pre>
<p><img src="ui/tui/./media/canvas_basic.png" alt="Basic Canvas" /></p>
<h3 id="function-plotting"><a class="header" href="#function-plotting">Function Plotting</a></h3>
<pre><code class="language-graphix">use tui;
use tui::canvas;

let coords = [
    (0.0, 0.0), (0.5, 0.48), (1.0, 0.84), (1.5, 1.0),
    (2.0, 0.91), (2.5, 0.60), (3.0, 0.14), (3.5, -0.35),
    (4.0, -0.76), (4.5, -0.98), (5.0, -0.96)
];

let plot = `Points({color: `Cyan, coords});

canvas(
    #x_bounds: &amp;{min: 0.0, max: 10.0},
    #y_bounds: &amp;{min: -1.0, max: 1.0},
    &amp;[&amp;plot]
)
</code></pre>
<p><img src="ui/tui/./media/canvas_plot.png" alt="Scatter Plot" /></p>
<h3 id="network-diagram"><a class="header" href="#network-diagram">Network Diagram</a></h3>
<pre><code class="language-graphix">use tui;
use tui::canvas;
use tui::text;

let circle1 = `Circle({color: `Blue, x: 2.0, y: 5.0, radius: 0.5});
let circle2 = `Circle({color: `Blue, x: 8.0, y: 5.0, radius: 0.5});
let circle3 = `Circle({color: `Blue, x: 5.0, y: 8.0, radius: 0.5});

let line1 = `Line({color: `White, x1: 2.0, y1: 5.0, x2: 8.0, y2: 5.0});
let line2 = `Line({color: `White, x1: 2.0, y1: 5.0, x2: 5.0, y2: 8.0});
let line3 = `Line({color: `White, x1: 8.0, y1: 5.0, x2: 5.0, y2: 8.0});

let all_shapes = [&amp;line1, &amp;line2, &amp;line3, &amp;circle1, &amp;circle2, &amp;circle3];

canvas(
    #x_bounds: &amp;{min: 0.0, max: 10.0},
    #y_bounds: &amp;{min: 0.0, max: 10.0},
    &amp;all_shapes
)
</code></pre>
<p><img src="ui/tui/./media/canvas_network.png" alt="Network Diagram" /></p>
<h3 id="animated-graphics"><a class="header" href="#animated-graphics">Animated Graphics</a></h3>
<pre><code class="language-graphix">use tui;
use tui::canvas;

let clock = time::timer(duration:0.1s, true);
let x = 0.0;
x &lt;- {
    let new_x = (clock ~ x) + 0.1;
    select new_x &gt; 10.0 { true =&gt; 0.0, false =&gt; new_x }
};

let moving_circle = `Circle({color: `Red, x, y: 5.0, radius: 1.0});

canvas(
    #x_bounds: &amp;{min: 0.0, max: 10.0},
    #y_bounds: &amp;{min: 0.0, max: 10.0},
    &amp;[&amp;moving_circle]
)
</code></pre>
<p><img src="ui/tui/./media/canvas_animated.gif" alt="Animated Canvas" /></p>
<h2 id="marker-comparison"><a class="header" href="#marker-comparison">Marker Comparison</a></h2>
<ul>
<li><strong>Braille</strong>: Highest resolution, smoothest curves, best for detailed graphics</li>
<li><strong>Dot</strong>: Fast rendering, lower resolution, good for simple shapes</li>
<li><strong>Block</strong>: High contrast, blocky appearance, good for filled areas</li>
</ul>
<h2 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h2>
<ul>
<li>Origin (0, 0) is at the bottom-left</li>
<li>X increases to the right</li>
<li>Y increases upward</li>
<li>Shapes outside bounds are clipped</li>
</ul>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="ui/tui/chart.html">chart</a> - For pre-built line charts</li>
<li><a href="ui/tui/barchart.html">barchart</a> - For bar-based visualizations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-chart-widget"><a class="header" href="#the-chart-widget">The Chart Widget</a></h1>
<p>The <code>chart</code> widget renders line charts with multiple datasets, custom axes, labels, and styling. It's ideal for visualizing time series data, trends, sensor readings, and any numeric data relationships.</p>
<h2 id="apis-4"><a class="header" href="#apis-4">APIs</a></h2>
<pre><code>mod chart: sig {
    type GraphType = [`Line, `Scatter];
    type Marker = [`Dot, `Braille, `Block];

    /// Creates a chart widget with datasets and axes
    val chart: fn(
        ?#style: &amp;Style,
        #x_axis: &amp;Axis,
        #y_axis: &amp;Axis,
        &amp;Array&lt;Dataset&gt;
    ) -&gt; Widget;

    /// Creates an axis configuration
    val axis: fn(
        ?#title: Line,
        ?#labels: Array&lt;Line&gt;,
        ?#style: Style,
        {min: f64, max: f64}
    ) -&gt; Axis;

    /// Creates a dataset to display on the chart
    val dataset: fn(
        ?#style: &amp;Style,
        ?#graph_type: &amp;GraphType,
        ?#marker: &amp;Marker,
        ?#name: &amp;Line,
        &amp;Array&lt;(f64, f64)&gt;
    ) -&gt; Dataset;
}
</code></pre>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<h3 id="chart"><a class="header" href="#chart">chart</a></h3>
<ul>
<li><strong>style</strong> - Background style for the chart area</li>
<li><strong>x_axis</strong> - X-axis configuration (required)</li>
<li><strong>y_axis</strong> - Y-axis configuration (required)</li>
</ul>
<h3 id="axis"><a class="header" href="#axis">axis</a></h3>
<ul>
<li><strong>title</strong> - Line for axis title</li>
<li><strong>labels</strong> - Array of lines displayed along axis</li>
<li><strong>style</strong> - Style for axis lines and ticks</li>
</ul>
<h3 id="dataset"><a class="header" href="#dataset">dataset</a></h3>
<ul>
<li><strong>style</strong> - Style for the dataset (line and markers)</li>
<li><strong>graph_type</strong> - <code>Line</code> or <code>Scatter</code></li>
<li><strong>marker</strong> - <code>Dot</code>, <code>Braille</code>, or <code>Block</code></li>
<li><strong>name</strong> - Line naming the dataset (for legends)</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::chart;

let data: Array&lt;(f64, f64)&gt; = [(0.0, 0.0), (1.0, 1.0), (2.0, 4.0), (3.0, 9.0)];

let ds = dataset(
    #style: &amp;style(#fg: `Cyan),
    #graph_type: &amp;`Line,
    #marker: &amp;`Dot,
    &amp;data
);

chart(
    #x_axis: &amp;axis({min: 0.0, max: 3.0}),
    #y_axis: &amp;axis({min: 0.0, max: 9.0}),
    &amp;[ds]
)
</code></pre>
<p><img src="ui/tui/./media/chart_basic.png" alt="Basic Chart" /></p>
<h3 id="real-time-data-visualization"><a class="header" href="#real-time-data-visualization">Real-time Data Visualization</a></h3>
<pre><code class="language-graphix">use tui;
use tui::chart;
use tui::text;

let data: Array&lt;(f64, f64)&gt; = {
    let clock = time::timer(duration:0.5s, true);
    let x = 0.0;
    x &lt;- (clock ~ x) + 1.0;
    let y = rand::rand(#clock, #start: f64:0., #end: f64:100.);
    let a = [];
    a &lt;- array::window(#n: 32, clock ~ a, (x, y));
    a
};

let ds = dataset(
    #style: &amp;style(#fg: `Cyan),
    #graph_type: &amp;`Line,
    #marker: &amp;`Dot,
    &amp;data
);

let label_style = style(#fg: `Yellow);

chart(
    #style: &amp;style(#bg: `Rgb({r: 20, g: 20, b: 20})),
    #x_axis: &amp;axis(
        #title: line(#style: label_style, "Time (s)"),
        #labels: [
            line(#style: label_style, "[(data[0]$).0]"),
            line(#style: label_style, "[(data[-1]$).0]")
        ],
        {min: (data[0]$).0, max: (data[-1]$).0}
    ),
    #y_axis: &amp;axis(
        #title: line(#style: label_style, "Value"),
        #labels: [
            line("0"), line("50"), line("100")
        ],
        {min: 0.0, max: 100.0}
    ),
    &amp;[ds]
)
</code></pre>
<p><img src="ui/tui/./media/chart_realtime.gif" alt="Real Time Chart" /></p>
<h3 id="multiple-datasets"><a class="header" href="#multiple-datasets">Multiple Datasets</a></h3>
<pre><code class="language-graphix">use tui;
use tui::chart;
use tui::text;

let temp_data = [(0.0, 20.0), (1.0, 22.0), (2.0, 21.5)];
let humidity_data = [(0.0, 50.0), (1.0, 55.0), (2.0, 52.0)];

let temp_ds = dataset(
    #style: &amp;style(#fg: `Red),
    #name: &amp;line("Temperature"),
    &amp;temp_data
);

let humidity_ds = dataset(
    #style: &amp;style(#fg: `Blue),
    #name: &amp;line("Humidity"),
    &amp;humidity_data
);

let x_axis =
    axis(#labels: [line("0"), line("1"), line("2")], {min: 0.0, max: 2.0});
let y_axis =
    axis(#labels: [line("0"), line("50"), line("100")], {min: 0.0, max: 100.0});

chart(
    #x_axis: &amp;x_axis,
    #y_axis: &amp;y_axis,
    &amp;[temp_ds, humidity_ds]
)
</code></pre>
<p><img src="ui/tui/./media/chart_multi.png" alt="Multi Chart" /></p>
<h2 id="marker-comparison-1"><a class="header" href="#marker-comparison-1">Marker Comparison</a></h2>
<ul>
<li><strong>Dot</strong>: Fastest, lowest resolution, good for dense data</li>
<li><strong>Braille</strong>: Smoothest curves, medium performance, best visual quality</li>
<li><strong>Block</strong>: High contrast, medium performance</li>
</ul>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="ui/tui/barchart.html">barchart</a> - For categorical data visualization</li>
<li><a href="ui/tui/sparkline.html">sparkline</a> - For compact inline charts</li>
<li><a href="ui/tui/canvas.html">canvas</a> - For custom graphics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-text-widget"><a class="header" href="#the-text-widget">The Text Widget</a></h1>
<p>The <code>text</code> widget renders styled text in the terminal. It's a fundamental building block for displaying formatted content with colors, modifiers, and multiple lines. Text is built from <code>Line</code> objects, which are in turn composed of <code>Span</code> objects.</p>
<h2 id="apis-5"><a class="header" href="#apis-5">APIs</a></h2>
<pre><code>mod text: sig {
    type Alignment = [`Left, `Center, `Right];
    type Modifier = [
        `Bold,
        `Italic,
        `Underlined,
        `SlowBlink,
        `RapidBlink,
        `Reversed,
        `Hidden,
        `CrossedOut
    ];
    type Color = [
        `Red, `Green, `Yellow, `Blue, `Magenta, `Cyan, `Gray, `DarkGray,
        `LightRed, `LightGreen, `LightYellow, `LightBlue, `LightMagenta, `LightCyan,
        `White, `Black,
        `Indexed(i64),
        `Rgb({r: i64, g: i64, b: i64})
    ];

    /// Creates styled text from a string or array of lines
    val text: fn(&amp;[string, Array&lt;Line&gt;]) -&gt; Widget;

    /// Creates a line of text from a string or array of spans
    val line: fn(?#style: Style, ?#alignment: Alignment, [string, Array&lt;Span&gt;]) -&gt; Line;

    /// Creates a styled text span
    val span: fn(?#style: Style, string) -&gt; Span;

    /// Creates a text style
    val style: fn(?#fg: Color, ?#bg: Color, ?#add_modifier: Modifier) -&gt; Style;
}
</code></pre>
<h2 id="text-hierarchy"><a class="header" href="#text-hierarchy">Text Hierarchy</a></h2>
<ul>
<li><strong>Span</strong>: A single segment of text with a single style</li>
<li><strong>Line</strong>: A collection of spans forming one line</li>
<li><strong>Text</strong>: A collection of lines forming multi-line content</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::text;

text(&amp;"Hello, World!")
</code></pre>
<p><img src="ui/tui/./media/text_basic.png" alt="Basic Text" /></p>
<h3 id="status-messages"><a class="header" href="#status-messages">Status Messages</a></h3>
<pre><code class="language-graphix">use tui;
use tui::text;

let make_status = |level, msg| select level {
    `Error =&gt; line([
        span(#style: style(#fg: `Red, #add_modifier: [`Bold]), "ERROR: "),
        span(msg)
    ]),
    `Warning =&gt; line([
        span(#style: style(#fg: `Yellow, #add_modifier: [`Bold]), "WARNING: "),
        span(msg)
    ]),
    `Info =&gt; line([
        span(#style: style(#fg: `Cyan), "INFO: "),
        span(msg)
    ])
};

text(&amp;[
    make_status(`Info, "Application started"),
    make_status(`Warning, "Cache miss"),
    make_status(`Error, "Connection failed")
])
</code></pre>
<p><img src="ui/tui/./media/text_status.png" alt="Multi Line Status" /></p>
<h3 id="dynamic-colors"><a class="header" href="#dynamic-colors">Dynamic Colors</a></h3>
<pre><code class="language-graphix">use tui;
use tui::text;

let count = 0;
let timer = time::timer(duration:1.s, true);
count &lt;- timer ~ (count + 1);

let colors = [`Red, `Green, `Yellow, `Blue, `Magenta, `Cyan];
let color = colors[count % array::len(colors)]$;

let l = line([
    span(#style: style(#fg: `White), "Count: "),
    span(#style: style(#fg: color, #add_modifier: [`Bold]), "[count]")
]);

text(&amp;[l])
</code></pre>
<p><img src="ui/tui/./media/text_dynamic.gif" alt="Dynamic Text" /></p>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<pre><code class="language-graphix">use tui;
use tui::text;

text(&amp;[
    line(#alignment: `Left, "Left aligned"),
    line(#alignment: `Center, "Centered"),
    line(#alignment: `Right, "Right aligned")
])
</code></pre>
<p><img src="ui/tui/./media/text_alignment.png" alt="Text Alignment" /></p>
<h2 id="color-support"><a class="header" href="#color-support">Color Support</a></h2>
<ul>
<li><strong>Named colors</strong>: <code>Red</code>, <code>Green</code>, <code>Blue</code>, <code>Yellow</code>, <code>Magenta</code>, <code>Cyan</code>, <code>White</code>, <code>Black</code>, <code>Gray</code>, <code>DarkGray</code>, and <code>Light*</code> variants</li>
<li><strong>Indexed colors</strong>: <code>Indexed(202)</code> for 256-color palette</li>
<li><strong>RGB colors</strong>: <code>Rgb({r: 255, g: 100, b: 50})</code> for true color</li>
</ul>
<h2 id="text-modifiers"><a class="header" href="#text-modifiers">Text Modifiers</a></h2>
<ul>
<li><code>Bold</code>, <code>Italic</code>, <code>Underlined</code>, <code>CrossedOut</code></li>
<li><code>SlowBlink</code>, <code>RapidBlink</code> (terminal support varies)</li>
<li><code>Reversed</code>, <code>Hidden</code></li>
</ul>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="ui/tui/paragraph.html">paragraph</a> - For wrapped and scrollable text</li>
<li><a href="ui/tui/block.html">block</a> - For containing text with borders</li>
<li><a href="ui/tui/list.html">list</a> - For selectable text items</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-paragraph-widget"><a class="header" href="#the-paragraph-widget">The Paragraph Widget</a></h1>
<p>The <code>paragraph</code> widget displays multi-line text with automatic word wrapping and scrolling support. It's ideal for displaying long text content, logs, or any content that needs to flow across multiple lines.</p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<pre><code class="language-graphix">mod paragraph: sig {
    type ScrollPosition = {x: i64, y: i64};

    /// Creates a paragraph widget with text content
    val paragraph: fn(
        ?#scroll: &amp;ScrollPosition,
        ?#alignment: &amp;Alignment,
        ?#wrap: &amp;bool,
        &amp;[string, Text]
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h2>
<ul>
<li><strong>scroll</strong> - Record with <code>x</code> and <code>y</code> fields for scroll position</li>
<li><strong>alignment</strong> - <code>Left</code>, <code>Center</code>, or <code>Right</code></li>
<li><strong>wrap</strong> - Enable/disable word wrapping (default: true)</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="basic-usage-7"><a class="header" href="#basic-usage-7">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::paragraph;

paragraph(&amp;"This is a simple paragraph. It will automatically wrap to fit the available width.")
</code></pre>
<p><img src="ui/tui/./media/paragraph_basic.png" alt="Basic Paragraph" /></p>
<h3 id="scrollable-content"><a class="header" href="#scrollable-content">Scrollable Content</a></h3>
<pre><code class="language-graphix">use tui;
use tui::paragraph;
use tui::block;
use tui::text;
use tui::input_handler;

let long_text = "I have got a lovely bunch of coconuts. Very long text continues here. More text. Even more text. This is a very long paragraph that will need scrolling to see all of it.";
let scroll_y = 0;

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Up if scroll_y &gt; 0 =&gt; {
                scroll_y &lt;- (k ~ scroll_y) - 1;
                `Stop
            },
            k@`Down if scroll_y &lt; 100 =&gt; {
                scroll_y &lt;- (k ~ scroll_y) + 1;
                `Stop
            },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

input_handler(
    #handle: &amp;handle_event,
    &amp;block(
        #border: &amp;`All,
        #title: &amp;line("Scrollable Text"),
        &amp;paragraph(
            #scroll: &amp;{x: 0, y: scroll_y},
            &amp;long_text
        )
    )
)
</code></pre>
<p><img src="ui/tui/./media/paragraph_scrollable.gif" alt="Scrollable Paragraph" /></p>
<h3 id="live-log-viewer"><a class="header" href="#live-log-viewer">Live Log Viewer</a></h3>
<p>Display real-time updating content:</p>
<pre><code class="language-graphix">use tui;
use tui::paragraph;
use tui::text;

let log_entries = [];
let new_entry = net::subscribe("/local/logs/application")?;

log_entries &lt;- array::window(
    #n: 100,
    new_entry ~ log_entries,
    line(cast&lt;string&gt;(new_entry)?)
);

paragraph(&amp;log_entries)
</code></pre>
<p><img src="ui/tui/./media/paragraph_log_viewer.gif" alt="Log Viewer" /></p>
<h3 id="centered-message"><a class="header" href="#centered-message">Centered Message</a></h3>
<pre><code class="language-graphix">use tui;
use tui::paragraph;
use tui::text;

paragraph(
    #alignment: &amp;`Center,
    &amp;[
        line(""),
        line(#style: style(#fg: `Yellow, #add_modifier: [`Bold]), "Welcome"),
        line(""),
        line("Press any key to continue")
    ]
)
</code></pre>
<p><img src="ui/tui/./media/paragraph_centered.png" alt="Paragraph Centered" /></p>
<h2 id="word-wrapping"><a class="header" href="#word-wrapping">Word Wrapping</a></h2>
<p>The paragraph widget automatically wraps long lines to fit the available width. Word boundaries are respected, so words won't be split in the middle unless they're longer than the available width.</p>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="ui/tui/text.html">text</a> - For creating styled text content</li>
<li><a href="ui/tui/scroll.html">scrollbar</a> - For adding scrollbars</li>
<li><a href="ui/tui/block.html">block</a> - For containing paragraphs with borders</li>
<li><a href="ui/tui/list.html">list</a> - For line-by-line selectable content</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gauge-widget"><a class="header" href="#the-gauge-widget">The Gauge Widget</a></h1>
<p>The <code>gauge</code> widget displays a single value as a filled progress indicator, perfect for showing percentages, completion status, or resource usage. It provides a clear visual representation of how full or complete something is.</p>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<pre><code class="language-graphix">mod gauge: sig {
    /// Creates a gauge widget showing progress from 0.0 to 1.0
    val gauge: fn(
        ?#gauge_style: &amp;Style,
        ?#label: &amp;Line,
        ?#use_unicode: &amp;bool,
        ?#style: &amp;Style,
        &amp;f64
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h2>
<ul>
<li><strong>gauge_style</strong> - Style for the filled portion</li>
<li><strong>label</strong> - Line or span displayed in the center</li>
<li><strong>use_unicode</strong> - Use Unicode block characters for smoother rendering</li>
<li><strong>style</strong> - Style for the unfilled portion</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="basic-usage-8"><a class="header" href="#basic-usage-8">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::gauge;

let progress = 0.75;  // 75%

gauge(
    #gauge_style: &amp;style(#fg: `Green),
    &amp;progress
)
</code></pre>
<p><img src="ui/tui/./media/gauge_basic.png" alt="Basic Gauge" /></p>
<h3 id="progress-with-color-thresholds"><a class="header" href="#progress-with-color-thresholds">Progress with Color Thresholds</a></h3>
<pre><code class="language-graphix">use tui;
use tui::gauge;
use tui::block;
use tui::text;

let clock = time::timer(duration:0.5s, true);
let power = 0.0;
power &lt;- min(1.0, (clock ~ power) + 0.01);

let color = select power {
    x if x &lt; 0.10 =&gt; `Red,
    x if x &lt; 0.25 =&gt; `Yellow,
    x =&gt; `Green
};

let percentage = cast&lt;i64&gt;(power * 100.0)?;

block(
    #border: &amp;`All,
    #title: &amp;line("Power Level"),
    &amp;gauge(
        #gauge_style: &amp;style(#fg: color),
        #label: &amp;span("[percentage]%"),
        &amp;power
    )
)
</code></pre>
<p><img src="ui/tui/./media/gauge_threshold.gif" alt="Gauge With Color" /></p>
<h3 id="resource-usage"><a class="header" href="#resource-usage">Resource Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::gauge;
use tui::text;

let used_memory = 6.5;  // GB
let total_memory = 16.0;  // GB
let usage_ratio = used_memory / total_memory;

let color = select usage_ratio {
    x if x &gt; 0.9 =&gt; `Red,
    x if x &gt; 0.7 =&gt; `Yellow,
    _ =&gt; `Green
};

gauge(
    #gauge_style: &amp;style(#fg: color),
    #label: &amp;span("[used_memory] GB / [total_memory] GB"),
    &amp;usage_ratio
)
</code></pre>
<p><img src="ui/tui/./media/gauge_resource.png" alt="Resource Usage Gauge" /></p>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="ui/tui/linegauge.html">linegauge</a> - For horizontal line-based gauges</li>
<li><a href="ui/tui/sparkline.html">sparkline</a> - For historical trend display</li>
<li><a href="ui/tui/barchart.html">barchart</a> - For comparing multiple values</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-line-gauge-widget"><a class="header" href="#the-line-gauge-widget">The Line Gauge Widget</a></h1>
<p>The <code>line_gauge</code> widget displays a horizontal progress indicator using line-drawing characters. It's more compact than <code>gauge</code> and ideal for dashboards where vertical space is limited.</p>
<h2 id="api-3"><a class="header" href="#api-3">API</a></h2>
<pre><code>mod linegauge: sig {
    type LineSet = [`Thin, `Thick, `Double];

    /// Creates a line gauge widget showing progress from 0.0 to 1.0
    val line_gauge: fn(
        ?#filled_style: &amp;Style,
        ?#unfilled_style: &amp;Style,
        ?#line_set: &amp;LineSet,
        ?#label: &amp;Line,
        ?#style: &amp;Style,
        &amp;f64
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h2>
<ul>
<li><strong>filled_style</strong> - Style for the filled portion</li>
<li><strong>unfilled_style</strong> - Style for the unfilled portion</li>
<li><strong>line_set</strong> - Character set: <code>Thin</code>, <code>Thick</code> (default), or <code>Double</code></li>
<li><strong>label</strong> - Line or span displayed within the gauge</li>
<li><strong>style</strong> - Base style for the widget</li>
</ul>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="basic-usage-9"><a class="header" href="#basic-usage-9">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::line_gauge;

let progress = 0.75;  // 75%

line_gauge(
    #filled_style: &amp;style(#fg: `Green),
    &amp;progress
)
</code></pre>
<p><img src="ui/tui/./media/linegauge_basic.png" alt="Basic Line Gauge" /></p>
<h3 id="color-coded-status"><a class="header" href="#color-coded-status">Color-coded Status</a></h3>
<pre><code class="language-graphix">use tui;
use tui::line_gauge;
use tui::block;
use tui::text;

{
    let clock = time::timer(duration:0.5s, true);
    let power = 0.0;
    power &lt;- min(1.0, (clock ~ power) + 0.01);

    let color = select power {
        x if x &lt; 0.10 =&gt; `Red,
        x if x &lt; 0.25 =&gt; `Yellow,
        x =&gt; `Green
    };

    let percentage = cast&lt;i64&gt;(power * 100.0)?;

    block(
        #border: &amp;`All,
        #title: &amp;line("Power"),
        &amp;line_gauge(
            #filled_style: &amp;style(#fg: color),
            #line_set: &amp;`Thick,
            #label: &amp;line("[percentage]%"),
            &amp;power
        )
    )
}
</code></pre>
<p><img src="ui/tui/./media/linegauge_colored.gif" alt="Line Gauge Color Coded" /></p>
<h3 id="compact-multi-metric-display"><a class="header" href="#compact-multi-metric-display">Compact Multi-metric Display</a></h3>
<pre><code class="language-graphix">use tui;
use tui::line_gauge;
use tui::text;
use tui::layout;

layout(
    #direction: &amp;`Vertical,
    &amp;[
        child(#constraint: `Percentage(5), line_gauge(
            #line_set:&amp;`Thick,
            #filled_style: &amp;style(#fg: `Red),
            #label: &amp;line("CPU 45%"),
            &amp;0.45
        )),
        child(#constraint: `Percentage(5), line_gauge(
            #line_set:&amp;`Thick,
            #filled_style: &amp;style(#fg: `Yellow),
            #label: &amp;line("MEM 67%"),
            &amp;0.67
        )),
        child(#constraint: `Percentage(5), line_gauge(
            #line_set:&amp;`Thick,
            #filled_style: &amp;style(#fg: `Green),
            #label: &amp;line("DSK 23%"),
            &amp;0.23
        ))
    ]
)
</code></pre>
<p><img src="ui/tui/./media/linegauge_multi.png" alt="Line Gauge Multi Colored" /></p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<ul>
<li>System resource monitors (CPU, RAM, disk, network)</li>
<li>Download/upload progress indicators</li>
<li>Compact status dashboards</li>
<li>Progress tracking in limited space</li>
</ul>
<h2 id="comparison-with-gauge"><a class="header" href="#comparison-with-gauge">Comparison with gauge</a></h2>
<p>Use <code>line_gauge</code> when:</p>
<ul>
<li>You need compact, single-line displays</li>
<li>Vertical space is limited</li>
<li>You want a more technical/modern look</li>
</ul>
<p>Use <code>gauge</code> when:</p>
<ul>
<li>You have more vertical space available</li>
<li>You want larger, more prominent indicators</li>
</ul>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="ui/tui/gauge.html">gauge</a> - For block-style progress indicators</li>
<li><a href="ui/tui/sparkline.html">sparkline</a> - For historical trend display</li>
<li><a href="ui/tui/barchart.html">barchart</a> - For categorical value comparison</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">input</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-layout-widget"><a class="header" href="#the-layout-widget">The Layout Widget</a></h1>
<p>The <code>layout</code> widget arranges child widgets in horizontal or vertical layouts with flexible sizing constraints. It's the primary tool for organizing complex TUI interfaces and supports focus management for interactive applications.</p>
<h2 id="apis-6"><a class="header" href="#apis-6">APIs</a></h2>
<pre><code>mod layout: sig {
    type Direction = [`Horizontal, `Vertical];
    type Flex = [`Start, `Center, `End, `SpaceAround, `SpaceBetween];
    type Constraint = [
        `Percentage(i64),
        `Length(i64),
        `Min(i64),
        `Max(i64),
        `Ratio(i64, i64),
        `Fill(i64)
    ];

    /// Creates a layout that arranges child widgets
    val layout: fn(
        ?#direction: &amp;Direction,
        ?#focused: &amp;i64,
        ?#flex: &amp;Flex,
        &amp;Array&lt;Child&gt;
    ) -&gt; Widget;

    /// Creates a child widget with sizing constraints
    val child: fn(?#constraint: Constraint, Widget) -&gt; Child;
}
</code></pre>
<h2 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h2>
<ul>
<li><strong>direction</strong> - <code>Horizontal</code> or <code>Vertical</code> (default: <code>Vertical</code>)</li>
<li><strong>focused</strong> - Index of the currently focused child (0-indexed)</li>
<li><strong>flex</strong> - Alignment when children don't fill space: <code>Start</code>, <code>Center</code>, <code>End</code>, <code>SpaceAround</code>, <code>SpaceBetween</code></li>
</ul>
<h2 id="constraint-types"><a class="header" href="#constraint-types">Constraint Types</a></h2>
<ul>
<li><strong>Percentage(n)</strong> - Allocates n% of available space</li>
<li><strong>Length(n)</strong> - Fixed width/height in cells</li>
<li><strong>Min(n)</strong> - At least n cells</li>
<li><strong>Max(n)</strong> - At most n cells</li>
<li><strong>Ratio(num, den)</strong> - Fractional allocation (num/den)</li>
<li><strong>Fill(n)</strong> - Takes remaining space after other constraints</li>
</ul>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="basic-layout"><a class="header" href="#basic-layout">Basic Layout</a></h3>
<pre><code class="language-graphix">use tui;
use tui::layout;
use tui::block;
use tui::text;

let content1 = text(&amp;"Sidebar content");
let content2 = text(&amp;"Main content");

let sidebar = block(#border: &amp;`All, #title: &amp;line("Sidebar"), &amp;content1);
let main = block(#border: &amp;`All, #title: &amp;line("Main"), &amp;content2);

layout(
    #direction: &amp;`Horizontal,
    &amp;[
        child(#constraint: `Percentage(30), sidebar),
        child(#constraint: `Percentage(70), main)
    ]
)
</code></pre>
<p><img src="ui/tui/./media/layout_basic.png" alt="Basic Layout" /></p>
<h3 id="three-pane-layout-with-focus"><a class="header" href="#three-pane-layout-with-focus">Three-Pane Layout with Focus</a></h3>
<pre><code class="language-graphix">use tui;
use tui::layout;
use tui::text;
use tui::input_handler;
use tui::block;

let focused = 0;

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Tab =&gt; {
                focused &lt;- ((k ~ focused) + 1) % 3;
                `Stop
            },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

let focused_border = |i| select focused { n if n == i =&gt; `All, _ =&gt; [`Top] };
let left_pane = block(#border:&amp;focused_border(0), &amp;text(&amp;"Left"));
let center_pane = block(#border:&amp;focused_border(1), &amp;text(&amp;"Center"));
let right_pane = block(#border:&amp;focused_border(2), &amp;text(&amp;"Right"));

input_handler(
    #handle: &amp;handle_event,
    &amp;layout(
        #direction: &amp;`Horizontal,
        #focused: &amp;focused,
        &amp;[
            child(#constraint: `Percentage(25), left_pane),
            child(#constraint: `Percentage(50), center_pane),
            child(#constraint: `Percentage(25), right_pane)
        ]
    )
)
</code></pre>
<p><img src="ui/tui/./media/layout_focus.gif" alt="Layout With Focus" /></p>
<h3 id="nested-layouts"><a class="header" href="#nested-layouts">Nested Layouts</a></h3>
<pre><code class="language-graphix">use tui;
use tui::layout;
use tui::text;
use tui::block;

let widget1 = block(#border:&amp;`All, &amp;text(&amp;"Widget 1"));
let widget2 = block(#border:&amp;`All, &amp;text(&amp;"Widget 2"));
let bottom_widget = block(#border:&amp;`All, &amp;text(&amp;"Bottom"));

let top_row = layout(
    #direction: &amp;`Horizontal,
    &amp;[
        child(#constraint: `Percentage(50), widget1),
        child(#constraint: `Percentage(50), widget2)
    ]
);

layout(
    #direction: &amp;`Vertical,
    &amp;[
        child(#constraint: `Percentage(50), top_row),
        child(#constraint: `Percentage(50), bottom_widget)
    ]
)
</code></pre>
<p><img src="ui/tui/./media/layout_nested.png" alt="Nested Layout" /></p>
<h3 id="headercontentfooter"><a class="header" href="#headercontentfooter">Header/Content/Footer</a></h3>
<pre><code class="language-graphix">use tui;
use tui::layout;
use tui::text;
use tui::block;

let header = block(#border:&amp;`All, &amp;text(&amp;"Header"));
let content = block(#border:&amp;`All, &amp;text(&amp;"Main Content"));
let footer = block(#border:&amp;`All, &amp;text(&amp;"Footer"));

layout(
    #direction: &amp;`Vertical,
    &amp;[
        child(#constraint: `Percentage(20), header),
        child(#constraint: `Fill(1), content),
        child(#constraint: `Percentage(20), footer)
    ]
)
</code></pre>
<p><img src="ui/tui/./media/layout_header_footer.png" alt="Layout With Header and Footer" /></p>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="ui/tui/block.html">block</a> - Common child widget for layouts</li>
<li><a href="ui/tui/../overview.html#input-handling">input_handler</a> - For handling focus changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-list-widget"><a class="header" href="#the-list-widget">The List Widget</a></h1>
<p>The <code>list</code> widget displays a scrollable, selectable list of items with keyboard navigation support. It's perfect for menus, file browsers, option selectors, and any interface that requires choosing from a list of items.</p>
<h2 id="api-4"><a class="header" href="#api-4">API</a></h2>
<pre><code class="language-graphix">mod list: sig {
    /// Creates a list widget from an array of lines
    val list: fn(
        ?#selected: &amp;i64,
        ?#scroll: &amp;i64,
        ?#highlight_style: &amp;Style,
        ?#highlight_symbol: &amp;string,
        ?#repeat_highlight_symbol: &amp;bool,
        ?#style: &amp;Style,
        &amp;Array&lt;Line&gt;
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h2>
<ul>
<li><strong>selected</strong> - Index of the currently selected item (0-indexed)</li>
<li><strong>scroll</strong> - Scroll position (offset from the top)</li>
<li><strong>highlight_style</strong> - Style for the selected item</li>
<li><strong>highlight_symbol</strong> - String displayed before selected item (e.g., "▶ ")</li>
<li><strong>repeat_highlight_symbol</strong> - Whether to repeat symbol on wrapped lines</li>
<li><strong>style</strong> - Base style for all list items</li>
</ul>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<h3 id="basic-usage-10"><a class="header" href="#basic-usage-10">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::list;

let items = [
    line("Apple"),
    line("Banana"),
    line("Cherry")
];

list(
    #selected: &amp;0,
    &amp;items
)
</code></pre>
<p><img src="ui/tui/./media/list_basic.png" alt="Basic List" /></p>
<h3 id="interactive-list-with-navigation"><a class="header" href="#interactive-list-with-navigation">Interactive List with Navigation</a></h3>
<pre><code class="language-graphix">use tui;
use tui::list;
use tui::block;
use tui::text;
use tui::input_handler;

let items = [
    line("Apple"), line("Banana"), line("Cherry"),
    line("Date"), line("Elderberry"), line("Fig"), line("Grape")
];

let last = array::len(items) - 1;
let selected = 0;
let scroll_pos = 0;
let visible = 5;

// Auto-scroll to keep selection visible
scroll_pos &lt;- select selected {
    s if s &lt; scroll_pos =&gt; s,
    s if s &gt; (scroll_pos + visible - 1) =&gt; s - visible + 1,
    _ =&gt; never()
};

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Up if selected &gt; 0 =&gt; {
                selected &lt;- (k ~ selected) - 1;
                `Stop
            },
            k@`Down if selected &lt; last =&gt; {
                selected &lt;- (k ~ selected) + 1;
                `Stop
            },
            k@`Home =&gt; { selected &lt;- k ~ 0; `Stop },
            k@`End =&gt; { selected &lt;- k ~ last; `Stop },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

input_handler(
    #handle: &amp;handle_event,
    &amp;block(
        #border: &amp;`All,
        #title: &amp;line("Fruit Selection"),
        &amp;list(
            #highlight_style: &amp;style(#fg: `Black, #bg: `Yellow),
            #highlight_symbol: &amp;"▶ ",
            #selected: &amp;selected,
            #scroll: &amp;scroll_pos,
            &amp;items
        )
    )
)
</code></pre>
<p><img src="ui/tui/./media/list_interactive.gif" alt="Interactive List" /></p>
<h3 id="styled-items"><a class="header" href="#styled-items">Styled Items</a></h3>
<pre><code class="language-graphix">use tui;
use tui::list;
use tui::text;

let make_item = |text, priority| select priority {
    `High =&gt; line(#style: style(#fg: `Red, #add_modifier: [`Bold]), text),
    `Medium =&gt; line(#style: style(#fg: `Yellow), text),
    `Low =&gt; line(#style: style(#fg: `White), text)
};

let items = [
    make_item("Critical bug", `High),
    make_item("Feature request", `Medium),
    make_item("Documentation", `Low)
];

list(#selected: &amp;0, &amp;items)
</code></pre>
<p><img src="ui/tui/./media/list_styled.png" alt="Styled List" /></p>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="ui/tui/table.html">table</a> - For multi-column structured data</li>
<li><a href="ui/tui/scroll.html">scrollbar</a> - For adding scrollbars</li>
<li><a href="ui/tui/block.html">block</a> - For containing lists with borders</li>
<li><a href="ui/tui/tabs.html">tabs</a> - For switching between different lists</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-scrollbar-widget"><a class="header" href="#the-scrollbar-widget">The Scrollbar Widget</a></h1>
<p>The <code>scrollbar</code> widget adds a visual scrollbar indicator to scrollable content, making it clear when content extends beyond the visible area and showing the current scroll position.</p>
<h2 id="api-5"><a class="header" href="#api-5">API</a></h2>
<pre><code class="language-graphix">mod scrollbar: sig {
    /// Wraps a widget with a scrollbar indicator
    val scrollbar: fn(
        #position: &amp;i64,
        ?#content_length: &amp;i64,
        ?#size: &amp;Size,
        &amp;Widget
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-11"><a class="header" href="#parameters-11">Parameters</a></h2>
<ul>
<li><strong>position</strong> (required) - Current scroll position (typically the Y offset)</li>
<li><strong>content_length</strong> - Total length of the content (auto-detected if not specified)</li>
<li><strong>size</strong> (output) - Rendered size of the scrollbar area</li>
</ul>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<h3 id="basic-usage-11"><a class="header" href="#basic-usage-11">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::scrollbar;
use tui::paragraph;

let long_text = "This is a very long text that needs scrolling. More content here. Even more content. And even more. Keep going with lots of text to demonstrate scrolling.";
let position = 0;
let content = paragraph(
    #scroll: &amp;{x: 0, y: position},
    &amp;long_text
);

scrollbar(
    #position: &amp;position,
    &amp;content
)
</code></pre>
<p><img src="ui/tui/./media/scroll_basic.png" alt="Basic Scrollbar" /></p>
<h3 id="scrollable-paragraph"><a class="header" href="#scrollable-paragraph">Scrollable Paragraph</a></h3>
<pre><code class="language-graphix">use tui;
use tui::scrollbar;
use tui::paragraph;
use tui::block;
use tui::text;
use tui::input_handler;

let long_text = "Very long text content...";
let position = 0;
let max_position = 100;

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Up if position &gt; 0 =&gt; {
                position &lt;- (k ~ position) - 1;
                `Stop
            },
            k@`Down if position &lt; max_position =&gt; {
                position &lt;- (k ~ position) + 1;
                `Stop
            },
            k@`PageUp if position &gt; 10 =&gt; {
                position &lt;- (k ~ position) - 10;
                `Stop
            },
            k@`PageDown if position &lt; (max_position - 10) =&gt; {
                position &lt;- (k ~ position) + 10;
                `Stop
            },
            k@`Home =&gt; { position &lt;- k ~ 0; `Stop },
            k@`End =&gt; { position &lt;- k ~ max_position; `Stop },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

input_handler(
    #handle: &amp;handle_event,
    &amp;block(
        #border: &amp;`All,
        #title: &amp;line("Scrollable Content"),
        &amp;scrollbar(
            #position: &amp;position,
            #content_length: &amp;max_position,
            &amp;paragraph(#scroll: &amp;{x: 0, y: position}, &amp;long_text)
        )
    )
)
</code></pre>
<p><img src="ui/tui/./media/scroll_paragraph.gif" alt="Scrollable Paragraph" /></p>
<h3 id="scrollable-list"><a class="header" href="#scrollable-list">Scrollable List</a></h3>
<pre><code class="language-graphix">use tui;
use tui::scrollbar;
use tui::list;
use tui::text;

let items = [
    line("Item 1"),
    line("Item 2"),
    line("Item 3"),
    line("Item 4"),
    line("Item 5")
];
let selected = 0;
let scroll_pos = 0;
let visible = 10;

// Auto-scroll to keep selection visible
scroll_pos &lt;- select selected {
    s if s &lt; scroll_pos =&gt; s,
    s if s &gt;= (scroll_pos + visible) =&gt; s - visible + 1,
    _ =&gt; never()
};

scrollbar(
    #position: &amp;scroll_pos,
    &amp;list(
        #scroll: &amp;scroll_pos,
        #selected: &amp;selected,
        &amp;items
    )
)
</code></pre>
<p><img src="ui/tui/./media/scroll_list.png" alt="Scrollable List" /></p>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="ui/tui/paragraph.html">paragraph</a> - For scrollable text content</li>
<li><a href="ui/tui/list.html">list</a> - For scrollable lists</li>
<li><a href="ui/tui/table.html">table</a> - For scrollable tables</li>
<li><a href="ui/tui/block.html">block</a> - For containing scrollable content</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-sparkline-widget"><a class="header" href="#the-sparkline-widget">The Sparkline Widget</a></h1>
<p>The <code>sparkline</code> widget renders compact inline charts perfect for dashboards and status displays. It shows data trends in minimal space, with support for color-coded bars based on thresholds.</p>
<h2 id="apis-7"><a class="header" href="#apis-7">APIs</a></h2>
<pre><code>mod sparkline: sig {
    type Direction = [`LeftToRight, `RightToLeft];

    /// Creates a sparkline widget from data values
    val sparkline: fn(
        ?#max: &amp;i64,
        ?#style: &amp;Style,
        ?#direction: &amp;Direction,
        &amp;Array&lt;[SparklineBar, f64]&gt;
    ) -&gt; Widget;

    /// Creates a sparkline bar with custom styling
    val sparkline_bar: fn(?#style: Style, f64) -&gt; SparklineBar;
}
</code></pre>
<h2 id="parameters-12"><a class="header" href="#parameters-12">Parameters</a></h2>
<h3 id="sparkline"><a class="header" href="#sparkline">sparkline</a></h3>
<ul>
<li><strong>max</strong> - Maximum value for scaling (auto-scales if not specified)</li>
<li><strong>style</strong> - Default style for bars</li>
<li><strong>direction</strong> - <code>LeftToRight</code> (default) or <code>RightToLeft</code></li>
</ul>
<h3 id="sparkline_bar"><a class="header" href="#sparkline_bar">sparkline_bar</a></h3>
<ul>
<li><strong>style</strong> - Style for this specific bar</li>
</ul>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<h3 id="basic-usage-12"><a class="header" href="#basic-usage-12">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::sparkline;

let data = [10.0, 25.0, 40.0, 55.0, 70.0, 85.0, 100.0];

sparkline(#max: &amp;100, &amp;data)
</code></pre>
<p><img src="ui/tui/./media/sparkline_basic.png" alt="Basic Sparkline" /></p>
<h3 id="threshold-based-coloring"><a class="header" href="#threshold-based-coloring">Threshold-based Coloring</a></h3>
<pre><code class="language-graphix">use tui;
use tui::sparkline;
use tui::block;
use tui::text;

let data = {
    let clock = time::timer(duration:0.3s, true);
    let v = rand::rand(#clock, #start:0., #end:100.);
    let d = [];
    let color = select v {
        v if v &lt;= 25. =&gt; `Green,
        v if v &lt;= 50. =&gt; `Yellow,
        _ =&gt; `Red
    };
    let v = sparkline_bar(#style: style(#fg: color), v);
    d &lt;- array::window(#n:80, clock ~ d, v);
    d
};

block(
    #border: &amp;`All,
    #title: &amp;line("Network Traffic Rate"),
    &amp;sparkline(
        #style: &amp;style(#fg: `Green),
        #max: &amp;100,
        &amp;data
    )
)
</code></pre>
<p><img src="ui/tui/./media/sparkline_threshold.gif" alt="Threshold Colors" /></p>
<h3 id="multi-metric-dashboard"><a class="header" href="#multi-metric-dashboard">Multi-metric Dashboard</a></h3>
<pre><code class="language-graphix">use tui;
use tui::sparkline;
use tui::block;
use tui::text;
use tui::layout;

let cpu_data = [50., 60., 55., 70., 65.];
let mem_data = [30., 35., 40., 38., 42.];
let net_data = [10., 20., 15., 25., 30.];

layout(
    #direction: &amp;`Vertical,
    &amp;[
        child(#constraint: `Percentage(33), block(
            #title: &amp;line("CPU"),
            &amp;sparkline(#style: &amp;style(#fg: `Red), #max: &amp;100, &amp;cpu_data)
        )),
        child(#constraint: `Percentage(33), block(
            #title: &amp;line("Memory"),
            &amp;sparkline(#style: &amp;style(#fg: `Yellow), #max: &amp;100, &amp;mem_data)
        )),
        child(#constraint: `Percentage(33), block(
            #title: &amp;line("Network"),
            &amp;sparkline(#style: &amp;style(#fg: `Cyan), &amp;net_data)
        ))
    ]
)
</code></pre>
<p><img src="ui/tui/./media/sparkline_dashboard.png" alt="Multi Sparkline Dashboard" /></p>
<h3 id="sparkline-from-netidx"><a class="header" href="#sparkline-from-netidx">Sparkline from Netidx</a></h3>
<pre><code class="language-graphix">use tui;
use tui::sparkline;

let data: Array&lt;f64&gt; = [];
let new_value = net::subscribe("/local/metrics/cpu")?;

data &lt;- array::window(
    #n: 60,
    new_value ~ data,
    cast&lt;f64&gt;(new_value)?
);

sparkline(#max: &amp;100, &amp;data)
</code></pre>
<p><img src="ui/tui/./media/sparkline_rolling.gif" alt="Rolling Sparkline" /></p>
<p>showing the output of the below shell pipeline during a netidx build,</p>
<pre><code>top | \
grep --line-buffered Cpu | \
awk '{ printf("/local/metrics/cpu|f64|%s\n", $6); fflush() }' | \
netidx publisher
</code></pre>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<p>Sparklines are ideal for:</p>
<ul>
<li>System resource monitoring (CPU, memory, network)</li>
<li>Real-time metrics dashboards</li>
<li>Compact data visualization in lists or tables</li>
<li>Rate of change visualization</li>
</ul>
<h2 id="see-also-14"><a class="header" href="#see-also-14">See Also</a></h2>
<ul>
<li><a href="ui/tui/chart.html">chart</a> - For detailed charts with axes</li>
<li><a href="ui/tui/gauge.html">gauge</a> - For single current value display</li>
<li><a href="ui/tui/linegauge.html">linegauge</a> - For horizontal progress bars</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-table-widget"><a class="header" href="#the-table-widget">The Table Widget</a></h1>
<p>The <code>table</code> widget displays structured data in rows and columns with support for selection, scrolling, and custom styling. It's ideal for data grids, process monitors, file listings, and any tabular data display.</p>
<h2 id="apis-8"><a class="header" href="#apis-8">APIs</a></h2>
<pre><code>mod table: sig {
    type HighlightSpacing = [`Always, `WhenSelected, `Never];

    /// Creates a table widget from an array of row references
    val table: fn(
        ?#header: &amp;Row,
        ?#selected: &amp;i64,
        ?#row_highlight_style: &amp;Style,
        ?#highlight_symbol: &amp;string,
        ?#highlight_spacing: &amp;HighlightSpacing,
        ?#widths: &amp;Array&lt;Constraint&gt;,
        ?#column_spacing: &amp;i64,
        ?#style: &amp;Style,
        &amp;Array&lt;&amp;Row&gt;
    ) -&gt; Widget;

    /// Creates a table row from cells
    val row: fn(?#style: Style, Array&lt;Cell&gt;) -&gt; Row;

    /// Creates a table cell from a line
    val cell: fn(?#style: Style, Line) -&gt; Cell;
}
</code></pre>
<h2 id="parameters-13"><a class="header" href="#parameters-13">Parameters</a></h2>
<ul>
<li><strong>header</strong> - Row object for the table header</li>
<li><strong>selected</strong> - Index of the currently selected row</li>
<li><strong>row_highlight_style</strong> - Style for the selected row</li>
<li><strong>highlight_symbol</strong> - String before selected row</li>
<li><strong>highlight_spacing</strong> - When to show highlight symbol: <code>Always</code>, <code>WhenSelected</code>, <code>Never</code></li>
<li><strong>widths</strong> - Array of column width constraints</li>
<li><strong>column_spacing</strong> - Number of spaces between columns</li>
<li><strong>style</strong> - Base style for the table</li>
</ul>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<h3 id="basic-usage-13"><a class="header" href="#basic-usage-13">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::table;

let header = row([
    cell(line("Name")),
    cell(line("Age")),
    cell(line("City"))
]);

let row1 = row([
    cell(line("Alice")),
    cell(line("28")),
    cell(line("New York"))
]);

let row2 = row([
    cell(line("Bob")),
    cell(line("32")),
    cell(line("San Francisco"))
]);

table(
    #header: &amp;header,
    #selected: &amp;0,
    &amp;[&amp;row1, &amp;row2]
)
</code></pre>
<p><img src="ui/tui/./media/table_basic.png" alt="Basic Table" /></p>
<h3 id="interactive-table"><a class="header" href="#interactive-table">Interactive Table</a></h3>
<pre><code class="language-graphix">use tui;
use tui::table;
use tui::block;
use tui::text;
use tui::input_handler;

type User = {name: string, age: i64, city: string};

let users: Array&lt;User&gt; = [
    {name: "Alice", age: 28, city: "New York"},
    {name: "Bob", age: 32, city: "San Francisco"},
    {name: "Charlie", age: 25, city: "Chicago"}
];

let header = row(
    #style: style(#fg: `Yellow, #add_modifier: [`Bold]),
    [cell(line("Name")), cell(line("Age")), cell(line("City"))]
);

let row1 = row([
    cell(line("Alice")),
    cell(line("28")),
    cell(line("New York"))
]);
let row2 = row([
    cell(line("Bob")),
    cell(line("32")),
    cell(line("San Francisco"))
]);
let row3 = row([
    cell(line("Charlie")),
    cell(line("25")),
    cell(line("Chicago"))
]);
let rows = [&amp;row1, &amp;row2, &amp;row3];

let selected = 0;

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Up if selected &gt; 0 =&gt; {
                selected &lt;- (k ~ selected) - 1;
                `Stop
            },
            k@`Down if selected &lt; 2 =&gt; {
                selected &lt;- (k ~ selected) + 1;
                `Stop
            },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

input_handler(
    #handle: &amp;handle_event,
    &amp;block(
        #border: &amp;`All,
        #title: &amp;line("User Directory"),
        &amp;table(
            #header: &amp;header,
            #row_highlight_style: &amp;style(#bg: `Yellow, #fg: `Black),
            #selected: &amp;selected,
            #column_spacing: &amp;2,
            #widths: &amp;[`Percentage(30), `Percentage(20), `Percentage(50)],
            &amp;rows
        )
    )
)
</code></pre>
<p><img src="ui/tui/./media/table_interactive.gif" alt="Interactive Table" /></p>
<h3 id="conditional-cell-styling"><a class="header" href="#conditional-cell-styling">Conditional Cell Styling</a></h3>
<pre><code class="language-graphix">use tui;
use tui::table;
use tui::text;

let make_cpu_cell = |cpu| {
    let s = select cpu {
        c if c &gt; 80 =&gt; style(#fg: `Red),
        c if c &gt; 50 =&gt; style(#fg: `Yellow),
        _ =&gt; style(#fg: `Green)
    };
    cell(#style: s, line("[cpu]%"))
};

let row1 = row([
    cell(line("process-1")),
    make_cpu_cell(85)  // Red
]);

let row2 = row([
    cell(line("process-2")),
    make_cpu_cell(60)  // Yellow
]);

let row3 = row([
    cell(line("process-3")),
    make_cpu_cell(30)  // Green
]);

let header = row([
    cell(#style: style(#add_modifier: [`Bold]), line("Process")),
    cell(#style: style(#add_modifier: [`Bold]), line("CPU"))
]);

table(
    #header: &amp;header,
    #widths: &amp;[`Percentage(60), `Percentage(40)],
    &amp;[&amp;row1, &amp;row2, &amp;row3]
)
</code></pre>
<p><img src="ui/tui/./media/table_styled_cells.png" alt="Conditional Styling" /></p>
<h3 id="real-time-updates"><a class="header" href="#real-time-updates">Real-time Updates</a></h3>
<pre><code class="language-graphix">use tui;
use tui::table;
use tui::text;

let clock = time::timer(duration:1.s, true);

let cpu_val = 5;
cpu_val &lt;- {
    let v = clock ~ cpu_val;
    v + rand::rand(#clock, #start: -5, #end: 5)
};

let row1 = row([
    cell(line("1")),
    cell(line("init")),
    cell(line("[cpu_val]%"))
]);
let row2 = row([
    cell(line("2")),
    cell(line("kthreadd")),
    cell(line("0%"))
]);
let rows = [&amp;row1, &amp;row2];

let header = row([cell(line("PID")), cell(line("Name")), cell(line("CPU"))]);
table(#header: &amp;header, &amp;rows)
</code></pre>
<p><img src="ui/tui/./media/table_realtime.gif" alt="Realtime Table" /></p>
<h2 id="see-also-15"><a class="header" href="#see-also-15">See Also</a></h2>
<ul>
<li><a href="ui/tui/list.html">list</a> - For simpler single-column selection</li>
<li><a href="ui/tui/scroll.html">scrollbar</a> - For adding scrollbars</li>
<li><a href="ui/tui/block.html">block</a> - For containing tables with borders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tabs-widget"><a class="header" href="#the-tabs-widget">The Tabs Widget</a></h1>
<p>The <code>tabs</code> widget creates a tabbed interface for organizing content into multiple switchable panels. Each tab has a title displayed in the tab bar and associated content that's shown when the tab is selected.</p>
<h2 id="api-6"><a class="header" href="#api-6">API</a></h2>
<pre><code class="language-graphix">mod tabs: sig {
    /// Creates a tabbed interface from an array of (title, content) tuples
    val tabs: fn(
        ?#selected: &amp;i64,
        ?#highlight_style: &amp;Style,
        ?#style: &amp;Style,
        ?#divider: &amp;[string, Span],
        &amp;Array&lt;(Line, Widget)&gt;
    ) -&gt; Widget;
}
</code></pre>
<h2 id="parameters-14"><a class="header" href="#parameters-14">Parameters</a></h2>
<ul>
<li><strong>selected</strong> - Index of the currently selected tab (0-indexed)</li>
<li><strong>highlight_style</strong> - Style for the selected tab title</li>
<li><strong>style</strong> - Base style for unselected tab titles</li>
<li><strong>divider</strong> - String or span separating tab titles</li>
</ul>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<h3 id="basic-usage-14"><a class="header" href="#basic-usage-14">Basic Usage</a></h3>
<pre><code class="language-graphix">use tui;
use tui::tabs;
use tui::paragraph;

let tab1 = paragraph(&amp;"This is tab 1");
let tab2 = paragraph(&amp;"This is tab 2");
let tab3 = paragraph(&amp;"This is tab 3");

tabs(
    #selected: &amp;0,
    &amp;[
        (line("One"), tab1),
        (line("Two"), tab2),
        (line("Three"), tab3)
    ]
)
</code></pre>
<p><img src="ui/tui/./media/tabs_basic.png" alt="Basic Tabs" /></p>
<h3 id="navigation-between-tabs"><a class="header" href="#navigation-between-tabs">Navigation Between Tabs</a></h3>
<pre><code class="language-graphix">use tui;
use tui::tabs;
use tui::block;
use tui::text;
use tui::input_handler;

let selected_tab = 0;

let handle_event = |e: Event| -&gt; [`Stop, `Continue] select e {
    `Key(k) =&gt; select k.kind {
        `Press =&gt; select k.code {
            k@`Left if selected_tab &gt; 0 =&gt; {
                selected_tab &lt;- (k ~ selected_tab) - 1;
                `Stop
            },
            k@`Right if selected_tab &lt; 2 =&gt; {
                selected_tab &lt;- (k ~ selected_tab) + 1;
                `Stop
            },
            k@`Tab =&gt; {
                selected_tab &lt;- ((k ~ selected_tab) + 1) % 3;
                `Stop
            },
            _ =&gt; `Continue
        },
        _ =&gt; `Continue
    },
    _ =&gt; `Continue
};

let overview = text(&amp;"Overview");
let items = text(&amp;"Items");
let settings = text(&amp;"Settings");

input_handler(
    #handle: &amp;handle_event,
    &amp;block(
        #border: &amp;`All,
        #title: &amp;line("Application (←/→ to navigate)"),
        &amp;tabs(
            #highlight_style: &amp;style(#fg: `Yellow, #add_modifier: [`Bold]),
            #style: &amp;style(#fg: `Gray),
            #selected: &amp;selected_tab,
            &amp;[
                (line("Overview"), overview),
                (line("Items"), items),
                (line("Settings"), settings)
             ]
        )
    )
)

</code></pre>
<p><img src="ui/tui/./media/tabs_navigation.gif" alt="Tabs With Navigation" /></p>
<h3 id="styled-tab-titles"><a class="header" href="#styled-tab-titles">Styled Tab Titles</a></h3>
<pre><code class="language-graphix">use tui;
use tui::tabs;
use tui::text;

let completed_content = text(&amp;"Completed");
let progress_content = text(&amp;"In Progress");
let failed_content = text(&amp;"Failed");

let tab_list = [
    (line([
        span(#style: style(#fg: `Green), "✓ "),
        span("Completed")
    ]), completed_content),
    (line([
        span(#style: style(#fg: `Yellow), "⚠ "),
        span("In Progress")
    ]), progress_content),
    (line([
        span(#style: style(#fg: `Red), "✗ "),
        span("Failed")
    ]), failed_content)
];

tabs(&amp;tab_list)
</code></pre>
<p><img src="ui/tui/./media/tabs_styled.png" alt="Styled Tabs" /></p>
<h3 id="tab-with-badge"><a class="header" href="#tab-with-badge">Tab with Badge</a></h3>
<pre><code class="language-graphix">use tui;
use tui::tabs;
use tui::text;

let unread_count = 5;

let messages_tab = line([
    span("Messages"),
    span(#style: style(#fg: `Red, #add_modifier: [`Bold]), " ([unread_count])")
]);

let home_content = text(&amp;"Home");
let messages_content = text(&amp;"Messages");
let settings_content = text(&amp;"Settings");

tabs(&amp;[
    (line("Home"), home_content),
    (messages_tab, messages_content),
    (line("Settings"), settings_content)
])
</code></pre>
<p><img src="ui/tui/./media/tabs_badge.png" alt="Tabs With Badges" /></p>
<h2 id="keyboard-navigation"><a class="header" href="#keyboard-navigation">Keyboard Navigation</a></h2>
<p>Common patterns:</p>
<ul>
<li><code>Left</code>/<code>Right</code> - Switch to previous/next tab</li>
<li><code>Tab</code> - Cycle forward through tabs</li>
<li>Number keys - Jump directly to tab</li>
</ul>
<h2 id="see-also-16"><a class="header" href="#see-also-16">See Also</a></h2>
<ul>
<li><a href="ui/tui/block.html">block</a> - For containing tabs with borders</li>
<li><a href="ui/tui/list.html">list</a> - Common content for tabs</li>
<li><a href="ui/tui/table.html">table</a> - For tabular content in tabs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-and-extending-graphix"><a class="header" href="#embedding-and-extending-graphix">Embedding and Extending Graphix</a></h1>
<p>There are multiple ways you can embed Graphix in your application and
extend it with rust code.</p>
<h2 id="writing-built-in-functions-in-rust"><a class="header" href="#writing-built-in-functions-in-rust">Writing built-in functions in rust</a></h2>
<p>You can implement Graphix functions in rust. Most of the standard
library is actually written in rust (to improve startup time), and you
can easily add more built-ins using rust code for computationally
heavy tasks, or IO.</p>
<p>There are two different ways to write built-ins, for a simple pure
function you can use a the <code>CachedArgs</code> interface which takes care of
most of the details for you. You only need to implement one method to
evaluate changes to your arguments. For example min finds the minimum
value of all it's arguments,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use graphix_stdlib::{deftype, CachedArgs, EvalCached};
use anyhow::{bail, Result};
use arcstr::{literal, ArcStr};
use netidx::subscriber::Value;

#[derive(Debug, Default)]
struct MinEv;

impl EvalCached for MinEv {
    const NAME: &amp;str = "min";
    deftype!("core", "fn('a, @args:'a) -&gt; 'a");

    fn eval(&amp;mut self, from: &amp;CachedVals) -&gt; Option&lt;Value&gt; {
        let mut res = None;
        for v in from.flat_iter() {
            match (res, v) {
                (None, None) | (Some(_), None) =&gt; return None,
                (None, Some(v)) =&gt; {
                    res = Some(v);
                }
                (Some(v0), Some(v)) =&gt; {
                    res = if v &lt; v0 { Some(v) } else { Some(v0) };
                }
            }
        }
        res
    }
}

type Min = CachedArgs&lt;MinEv&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Then you must register this built-in with the exec context,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.register_builtin::&lt;Min&gt;()?
<span class="boring">}</span></code></pre></pre>
<p>And then you can call it from Graphix,</p>
<pre><code class="language-graphix">let min = |@args| 'min
</code></pre>
<p>The special form function body <code>'min</code> references a built-in rust
function.</p>
<p>See <a href="embedding/./builtins.html">Writing Built in Functions</a> for details.</p>
<h2 id="building-stand-alone-graphix-applications"><a class="header" href="#building-stand-alone-graphix-applications">Building Stand Alone Graphix Applications</a></h2>
<p>You can build single binary stand alone Graphix applications using the
<code>graphix-shell</code> crate. All your Graphix source code, and built-ins are
compiled together with the compiler and runtime into a single binary
that you can then deploy and run. When combined with writing built-ins
in rust this becomes a powerful mixed language toolset.</p>
<p>For example here is the netidx browser from <code>netidx-tools</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::publisher;
use anyhow::{Context, Result};
use arcstr::literal;
use graphix_rt::NoExt;
use graphix_shell::{Mode, ShellBuilder};
use netidx::{
    config::Config,
    publisher::{DesiredAuth, PublisherBuilder},
    subscriber::Subscriber,
};

pub async fn run(
    cfg: Config,
    auth: DesiredAuth,
    params: publisher::Params,
) -&gt; Result&lt;()&gt; {
    let publisher = PublisherBuilder::new(cfg.clone())
        .desired_auth(auth.clone())
        .bind_cfg(params.bind)
        .build()
        .await
        .context("creating publisher")?;
    let subscriber = Subscriber::new(cfg, auth).context("create subscriber")?;
    ShellBuilder::&lt;NoExt&gt;::default()
        .mode(Mode::Static(literal!(include_str!("browser.gx"))))
        .publisher(publisher)
        .subscriber(subscriber)
        .no_init(true)
        .build()?
        .run()
        .await
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="embedding/./shell.html">Stand Alone Graphix Applications</a> for details</p>
<h2 id="embedding-graphix-in-your-application"><a class="header" href="#embedding-graphix-in-your-application">Embedding Graphix in Your Application</a></h2>
<p>Using the <code>graphix-rt</code> crate you can embed the Graphix compiler and
runtime in your application. Then you can,</p>
<ul>
<li>compile and run Graphix code</li>
<li>receive events from Graphix expressions</li>
<li>inject events into Graphix pipelines</li>
<li>call Graphix functions</li>
</ul>
<p>The runtime uses tokio and runs in a background task so it integrates
well into a normal async workflow.</p>
<p>See <a href="embedding/./rt.html">Using Graphix as Embedded Scripting</a> for details</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-built-in-functions"><a class="header" href="#writing-built-in-functions">Writing Built in Functions</a></h1>
<p>As mentioned in the introduction you can extend Graphix by writing
built in functions in rust. This chapter will deep dive into the full
API, if you just want to write a pure function see the
<a href="embedding/./overview.html">Overview</a>.</p>
<p>In order to implement a built-in graphix function you must implement
two traits,
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/trait.BuiltIn.html"><code>graphix_compiler::BuiltIn</code></a>
and
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/trait.Apply.html"><code>graphix_compiler::Apply</code></a>. See
the rustdoc for details. These two traits give you more control than the
<a href="https://docs.rs/graphix-stdlib/latest/graphix_stdlib/struct.CachedArgs.html"><code>graphix_stdlib::CachedArgs</code></a> method we covered in the overview. Lets look at the simplest possible example,</p>
<h2 id="understanding-the-once-function"><a class="header" href="#understanding-the-once-function">Understanding The Once Function</a></h2>
<p>The <code>once</code> function evaluates it's arugment every cycle and passes
through one and only one update. The <code>update</code> method is the most
important method of <code>Apply</code>, it is called every cycle and returns
something only when the node being updated has "updated". The meaning
of that is specific to what the node does, but in the case of <code>once</code>
it means that the argument to <code>once</code> updated, and <code>once</code> has not
already seen an update. Consider the example program,</p>
<pre><code class="language-graphix">let clock = time::timer(1, true);
println(once(clock))
</code></pre>
<p>We expect this example to print the datetime exactly one time. Lets
dig in to how that actually works. The clock created by <code>time::timer</code>
will tick once per second forever. The <code>time::timer</code> built-in will
call <code>set_timer</code> in the
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/trait.Rt.html"><code>Rt</code></a>,
which is part of the
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/struct.ExecCtx.html"><code>ExecCtx</code></a>. This
will schedule a cycle to happen 1 second from now, and will also
register that this toplevel node (<code>let clock = ...</code>) depends on the
timer event. When the timer event happens the approximate sequence of
events is,</p>
<ul>
<li>let clock = time::timer(1, true), update called on toplevel node (Bind)
<ul>
<li>time::timer(1, true), bind calls update on it's rhs</li>
<li>time::timer checks events to see if it should update, returns Some(DateTime(..))</li>
<li>bind sets the id of clock in events to Value::DateTime(..)</li>
<li>Rt checks for nodes that depend on <code>clock</code> schedules println(..)</li>
</ul>
</li>
<li>println(once(clock)), update called on toplevel node (CallSite)
<ul>
<li>once(clock), println calls update on it's argument, once(clock)</li>
<li>once::update calls update on clock</li>
<li>ref clock checks events to see if it updated, returns Some(Value::DateTime(..))</li>
<li>once::update checks if it's the first time it's argument has updated, it is</li>
<li>once::update returns Some(Value::DateTime(..))</li>
<li>println prints the datetime</li>
</ul>
</li>
</ul>
<h2 id="implementing-once"><a class="header" href="#implementing-once">Implementing Once</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Once {
    val: bool,
}

impl&lt;R: Rt, E: UserEvent&gt; BuiltIn&lt;R, E&gt; for Once {
    const NAME: &amp;str = "once";
    deftype!("core", "fn('a) -&gt; 'a");

    fn init(_: &amp;mut ExecCtx&lt;R, E&gt;) -&gt; BuiltInInitFn&lt;R, E&gt; {
        Arc::new(|_, _, _, _, _| Ok(Box::new(Once { val: false })))
    }
}

impl&lt;R: Rt, E: UserEvent&gt; Apply&lt;R, E&gt; for Once {
    fn update(
        &amp;mut self,
        ctx: &amp;mut ExecCtx&lt;R, E&gt;,
        from: &amp;mut [Node&lt;R, E&gt;],
        event: &amp;mut Event&lt;E&gt;,
    ) -&gt; Option&lt;Value&gt; {
        match from {
            [s] =&gt; s.update(ctx, event).and_then(|v| {
                if self.val {
                    None
                } else {
                    self.val = true;
                    Some(v)
                }
            }),
            _ =&gt; None,
        }
    }

    fn sleep(&amp;mut self, _ctx: &amp;mut ExecCtx&lt;R, E&gt;) {
        self.val = false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The BuiltIn trait is for construction, it declares the built in's
name, and it's type (which we get to write out in syntax due to the
deftype macro). It's init method is called every time the built in
needs to be registered with a new context, and returns a closure that
allocates the initial state of the function given a bunch of
information about the context it's called in. In this case we don't
care about any of that information, but it will be useful later.</p>
<p>The most important method of <code>Apply</code> is update. <code>sleep</code> is expected to
reset all the internal state and unregister anything registered with
the context.</p>
<h2 id="higher-order-functions-1"><a class="header" href="#higher-order-functions-1">Higher Order Functions</a></h2>
<p>Right, now that the easy stuff is out of the way, lets see how we can
implement a built-in that takes another Graphix function as an
argument. This gets compiler guts all over the place, sorry about
that. Again lets look at the simplest example from the standard
library, which is <code>array::group</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub(super) struct Group&lt;R: Rt, E: UserEvent&gt; {
    queue: VecDeque&lt;Value&gt;,
    buf: SmallVec&lt;[Value; 16]&gt;,
    pred: Node&lt;R, E&gt;,
    ready: bool,
    pid: BindId,
    nid: BindId,
    xid: BindId,
}

impl&lt;R: Rt, E: UserEvent&gt; BuiltIn&lt;R, E&gt; for Group&lt;R, E&gt; {
    const NAME: &amp;str = "array_group";
    deftype!(
        "core::array",
        "fn('a, fn(i64, 'a) -&gt; bool throws 'e) -&gt; Array&lt;'a&gt; throws 'e"
    );

    fn init(_: &amp;mut ExecCtx&lt;R, E&gt;) -&gt; BuiltInInitFn&lt;R, E&gt; {
        Arc::new(|ctx, typ, scope, from, top_id| match from {
            [_, _] =&gt; {
                let scope =
                    scope.append(&amp;format_compact!("fn{}", LambdaId::new().inner()));
                let n_typ = Type::Primitive(Typ::I64.into());
                let etyp = typ.args[0].typ.clone();
                let mftyp = match &amp;typ.args[1].typ {
                    Type::Fn(ft) =&gt; ft.clone(),
                    t =&gt; bail!("expected function not {t}"),
                };
                let (nid, n) =
                    genn::bind(ctx, &amp;scope.lexical, "n", n_typ.clone(), top_id);
                let (xid, x) = genn::bind(ctx, &amp;scope.lexical, "x", etyp.clone(), top_id);
                let pid = BindId::new();
                let fnode = genn::reference(ctx, pid, Type::Fn(mftyp.clone()), top_id);
                let pred = genn::apply(fnode, scope, vec![n, x], &amp;mftyp, top_id);
                Ok(Box::new(Self {
                    queue: VecDeque::new(),
                    buf: smallvec![],
                    pred,
                    ready: true,
                    pid,
                    nid,
                    xid,
                }))
            }
            _ =&gt; bail!("expected two arguments"),
        })
    }
}

impl&lt;R: Rt, E: UserEvent&gt; Apply&lt;R, E&gt; for Group&lt;R, E&gt; {
    fn update(
        &amp;mut self,
        ctx: &amp;mut ExecCtx&lt;R, E&gt;,
        from: &amp;mut [Node&lt;R, E&gt;],
        event: &amp;mut Event&lt;E&gt;,
    ) -&gt; Option&lt;Value&gt; {
        macro_rules! set {
            ($v:expr) =&gt; {{
                self.ready = false;
                self.buf.push($v.clone());
                let len = Value::I64(self.buf.len() as i64);
                ctx.cached.insert(self.nid, len.clone());
                event.variables.insert(self.nid, len);
                ctx.cached.insert(self.xid, $v.clone());
                event.variables.insert(self.xid, $v);
            }};
        }
        if let Some(v) = from[0].update(ctx, event) {
            self.queue.push_back(v);
        }
        if let Some(v) = from[1].update(ctx, event) {
            ctx.cached.insert(self.pid, v.clone());
            event.variables.insert(self.pid, v);
        }
        if self.ready &amp;&amp; self.queue.len() &gt; 0 {
            let v = self.queue.pop_front().unwrap();
            set!(v);
        }
        loop {
            match self.pred.update(ctx, event) {
                None =&gt; break None,
                Some(v) =&gt; {
                    self.ready = true;
                    match v {
                        Value::Bool(true) =&gt; {
                            break Some(Value::Array(ValArray::from_iter_exact(
                                self.buf.drain(..),
                            )))
                        }
                        _ =&gt; match self.queue.pop_front() {
                            None =&gt; break None,
                            Some(v) =&gt; set!(v),
                        },
                    }
                }
            }
        }
    }

    fn typecheck(
        &amp;mut self,
        ctx: &amp;mut ExecCtx&lt;R, E&gt;,
        _from: &amp;mut [Node&lt;R, E&gt;],
    ) -&gt; anyhow::Result&lt;()&gt; {
        self.pred.typecheck(ctx)
    }

    fn refs(&amp;self, refs: &amp;mut Refs) {
        self.pred.refs(refs)
    }

    fn delete(&amp;mut self, ctx: &amp;mut ExecCtx&lt;R, E&gt;) {
        ctx.cached.remove(&amp;self.nid);
        ctx.cached.remove(&amp;self.pid);
        ctx.cached.remove(&amp;self.xid);
        self.pred.delete(ctx);
    }

    fn sleep(&amp;mut self, ctx: &amp;mut ExecCtx&lt;R, E&gt;) {
        self.pred.sleep(ctx);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implements <code>array::group</code>, which given an argument, stores that
argument's updates internally, and creates an array out of them when
the predicate returns true. It's type is</p>
<p><code>fn('a, fn(i64, 'a) -&gt; bool) -&gt; Array&lt;'a&gt;</code></p>
<p>For example,</p>
<pre><code class="language-graphix">let n = seq(0, 100);
array::group(n, |_, n| (n == 50) || (n == 99))
</code></pre>
<p><code>seq(0, 100)</code> updates 100 times from 0 to 99. The <code>array::group</code> will
create two arrays, one containing <code>[0, .. 50]</code> and the other
containing <code>[51, .. 99]</code></p>
<p>The implementation needs to build a <code>Node</code> representing the
predicate. <code>Node</code> is the fundamental type of everything in the graph,
ultimately the entire program compiles to a node. The kind of node we
need to create here is a function call site, that will handle all the
details of late binding optional arguments, default args, etc,
etc. The <code>genn</code> module is specifically for generating nodes.</p>
<h3 id="typecheck"><a class="header" href="#typecheck">Typecheck</a></h3>
<p>Because we generated code, we have to hook into the <code>typecheck</code>
compiler phase and make sure the type checker runs on it. This
requires that we implement the <code>typecheck</code> method. In our case all we
have to do is typecheck our generated call site. You can do powerful
things with this hook however.</p>
<h3 id="bindids-and-refs"><a class="header" href="#bindids-and-refs">BindIds and Refs</a></h3>
<p><code>BindId</code> is a very fundamental type in compiler guts. The
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/struct.Event.html"><code>Event</code></a>
struct contains two tables indexed by it. The most important is
<code>variables</code>. Every bound variable has a <code>BindId</code>. If a variable has
updated this cycle, then it's updated value will be in the <code>variables</code>
table indexed by it's <code>BindId</code>. In order to call this predicate
function we actually create three different variables and store their
<code>BindIds</code> as <code>xid</code>, <code>nid</code>, and <code>pid</code>. <code>gen::ref</code> returns a reference
<code>Node</code> and the <code>BindId</code> of the variable it is referencing. Since those
ref nodes become the arguments to the predicate call site we create,
<code>xid</code> and <code>nid</code> allow us to control the arguments passed into the
function. We just have to set <code>xid</code> and <code>nid</code> in <code>Event::variables</code>
before we update the predicate in order to <code>call</code> the function. This
may cause it to update immediatly, or, it may depend on something else
that needs to update before it will update. Either way, once we've set
<code>xid</code> and <code>nid</code> once and called update on the predicate we've done our
duty (it may never update, and that's ok). That just leaves <code>pid</code>,
what is it for? Well, earlier it was mentioned that functions are
always late bound. This is how that works. The lambda argument we were
passed <code>from[1]</code>, whatever kind of node it is, will ultimately update
and return a <code>LambdaId</code>, which is an index into a table in the context
where all compiled functions actually reside. So every cycle we need
to call update on this node just like any other node, because the
<code>LambdaId</code> of the function we are supposed to be calling might change,
and if that happens the call site we created with <code>genn::apply</code> needs
to know about it. Luckily we don't have to handle any of the wonderful
details of late binding beyond this simple passing through of updates,
the call site will take care of that.</p>
<h3 id="execctxcached-refs-delete"><a class="header" href="#execctxcached-refs-delete">ExecCtx::cached, refs, delete</a></h3>
<p>What is all this <code>ctx.cached</code> stuff. Well, when call sites get
initialized for the first time, or when an branch of select wakes from
sleep, it turns out we need to know what the current value of every
variable they depend on is. Which means we need to cache globally the
current value of every variable. So if you're setting variables, 90%
chance you need to update cached.</p>
<p>And this also explains another function that you have to implement
when you're generating nodes, which is refs. Turns out we need to know
all the variables a node depends on, so we can, you know, set them
when it's being woken up from sleep, or stood up at a call site for
the first time.</p>
<p>That just leaves <code>delete</code>. Turns out the structure of the graph
changes at run time, and we need to keep everything straight. It would
be nice if we could do this with <code>Drop</code>, but that would require
holding a reference to the <code>ExecCtx</code> we are in at every <code>Node</code>. I'd
really rather not pay to wrap every access to the context in a mutex,
so we're doing it the hard way (for now).</p>
<h2 id="dynamic-linking-and-non-rust-builtins"><a class="header" href="#dynamic-linking-and-non-rust-builtins">Dynamic Linking and Non Rust Builtins</a></h2>
<p>At the moment there is no dynamic linking of rust built-ins, nor is there
explicit support for writing built-ins in a language other than rust. However
both of those goals are on the roadmap.</p>
<p>Essentially the plan is to export a minimal C abi interface for adding built-ins
to Graphix, and then any language that can target that abi can be used directly
to write Graphix built-ins, and we can dynamically load built-ins from shared
libraries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stand-alone-graphix-applications"><a class="header" href="#stand-alone-graphix-applications">Stand Alone Graphix Applications</a></h1>
<p>As we saw in the overview, using the
<a href="https://docs.rs/graphix-shell/latest/graphix_shell">graphix-shell</a> crate you
can build a stand alone Graphix application using rust. With those basics out of
the way, in this section we'll see,</p>
<ul>
<li>linking multiple Graphix files into a module tree</li>
<li>integrating rust built-ins</li>
<li>building a custom repl with rust built-ins added</li>
</ul>
<h2 id="module-trees-vfs-resolver"><a class="header" href="#module-trees-vfs-resolver">Module Trees, VFS resolver</a></h2>
<p>In order to split a stand alone Graphix application up into mutiple files and
modules and link it all into a single rust binary you can use a kind of module
resolver called the <code>VFS</code>. This is pretty much exactly what it sounds like. Here
is an example from the TUI library that is built into the shell by default.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tui_mods() -&gt; ModuleResolver {
    ModuleResolver::VFS(HashMap::from_iter([
        (Path::from("/tui"), literal!(include_str!("tui/mod.gx"))),
        (Path::from("/tui/input_handler"), literal!(include_str!("tui/input_handler.gx"))),
        (Path::from("/tui/text"), literal!(include_str!("tui/text.gx"))),
        (Path::from("/tui/paragraph"), literal!(include_str!("tui/paragraph.gx"))),
        (Path::from("/tui/block"), literal!(include_str!("tui/block.gx"))),
        (Path::from("/tui/scrollbar"), literal!(include_str!("tui/scrollbar.gx"))),
        (Path::from("/tui/layout"), literal!(include_str!("tui/layout.gx"))),
        (Path::from("/tui/tabs"), literal!(include_str!("tui/tabs.gx"))),
        (Path::from("/tui/barchart"), literal!(include_str!("tui/barchart.gx"))),
        (Path::from("/tui/chart"), literal!(include_str!("tui/chart.gx"))),
        (Path::from("/tui/sparkline"), literal!(include_str!("tui/sparkline.gx"))),
        (Path::from("/tui/line_gauge"), literal!(include_str!("tui/line_gauge.gx"))),
        (Path::from("/tui/gauge"), literal!(include_str!("tui/gauge.gx"))),
        (Path::from("/tui/list"), literal!(include_str!("tui/list.gx"))),
        (Path::from("/tui/table"), literal!(include_str!("tui/table.gx"))),
        (Path::from("/tui/calendar"), literal!(include_str!("tui/calendar.gx"))),
        (Path::from("/tui/canvas"), literal!(include_str!("tui/canvas.gx"))),
        (Path::from("/tui/browser"), literal!(include_str!("tui/browser.gx"))),
    ]))
}
<span class="boring">}</span></code></pre></pre>
<p>And then when you build the shell, you can specify this
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/expr/enum.ModuleResolver.html"><code>ModuleResolver</code></a>,
and your toplevel program can simply <code>use</code> these modules as if they were files
on disk.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ShellBuilder::&lt;NoExt&gt;::default()
    .module_resolvers(vec![tui_mods()])
    .mode(Mode::Static(literal!(include_str!("main.gx"))))
    .publisher(publisher)
    .subscriber(subscriber)
    .no_init(true)
    .build()?
    .run()
    .await
<span class="boring">}</span></code></pre></pre>
<p>You can have as many module resolvers as you like, when loading modules they are
checked in order, so earlier ones shadow later ones.</p>
<h2 id="custom-builtins"><a class="header" href="#custom-builtins">Custom Builtins</a></h2>
<p>To use custom builtins with the shell you must provide a register function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn register(ctx: &amp;mut ExecCtx&lt;NoExt&gt;) -&gt; Result&lt;ArcStr&gt; {
    BuiltIn0::register(ctx)?;
    BuiltIn1::register(ctx)?;
    Ok(literal!("builtins.gx"))
}

ShellBuilder::&lt;NoExt&gt;::default()
    .register(Arc::new(|ctx| register(ctx)))
    .module_resolvers(vec![tui_mods()])
    .mode(Mode::Static(literal!(include_str!("main.gx"))))
    .publisher(publisher)
    .subscriber(subscriber)
    .no_init(true)
    .build()?
    .run()
    .await
<span class="boring">}</span></code></pre></pre>
<p>See <a href="embedding/./builtins.html">Implementing Builtins</a> for details on actually implementing
builtins.</p>
<h2 id="custom-repl"><a class="header" href="#custom-repl">Custom REPL</a></h2>
<p>You can build a REPL with custom additional Graphix code, or custom builtins,
when you build your shell, just change the mode to <code>Mode::Repl</code>. Then you'll get
a custom REPL with your desired builtins and pre loaded modules already present.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-scripting-systems"><a class="header" href="#embedded-scripting-systems">Embedded Scripting Systems</a></h1>
<p>You can use Graphix as an embedded scripting engine in your application. For
this application we leave the shell behind and move to the
<a href="https://docs.rs/graphix-rt/latest/graphix_rt"><code>graphix-rt</code></a> crate. This is a
lower level crate that gives you a lot more control over the compiler and run
time.</p>
<h2 id="tokio"><a class="header" href="#tokio">Tokio</a></h2>
<p><code>graphix-rt</code> uses tokio internally, it will run the compiler and run loop in
it's own tokio task. You Interface with this task via a
<a href="https://docs.rs/graphix-rt/latest/graphix_rt/struct.GXHandle.html"><code>GXHandle</code></a>.
As a result, all operations on Graphix objects are async, and the compiler/run
loop will run in parallel with your application.</p>
<h2 id="setting-it-up"><a class="header" href="#setting-it-up">Setting it up</a></h2>
<p>The shell itself is actually the best example of using the <code>graphix-rt</code> crate.
As we get further into internals, the details can change more often, but in
general getting a Graphix runtime going involves the following,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// set up an execution context using the generic runtime with no customization
let mut ctx = ExecCtx::new(GXRt::&lt;NoExt&gt;::new(publisher, subscriber));
// ... use the context to register all your built-ins, etc

// set up a channel to receive events from the RT
let (tx, rx) = mpsc::channel(100);
// build the config and start the runtime
let handle = GXConfig::builder(ctx, tx)
    // set up a root module. Note if you want the standard library you must load
    // it as part of the root module. Otherwise you will get the bare compiler.
    .root(literal!("root.gx"))
    .build()?
    .start().await?
<span class="boring">}</span></code></pre></pre>
<p>Once that all succeeds you have a running compiler/run loop, and a handle that
can interact with it. You are expected to read the <code>rx</code> portion of the mpsc
channel. If you do not, the run loop will block waiting for you to read once the
mpsc channel fills up.</p>
<h2 id="compiling-code-getting-results"><a class="header" href="#compiling-code-getting-results">Compiling Code, Getting Results</a></h2>
<p>Once setup is complete, lets compile some code and get some results! To compile
code we call
<a href="https://docs.rs/graphix-rt/latest/graphix_rt/struct.GXHandle.html#method.compile"><code>compile</code></a>
on the handle. This results in one or more toplevel expressions and a copy of
the environment (or a compile error).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cres = handle.compile(literal!("2 + 2")).await?;

// in this case we know there is just one top level expression
let e = cres.exprs[0];

// the actual result will come to us on the channel. If the expression kept
// producing results, we'd keep seeing updates for it's id on the channel.
// This is a batch of GXEvents
let mut batch = rx.recv().await.ok_or_else(|| anyhow!("the runtime is dead"))?;
let mut env = handle.get_env().await?;
for ev in batch.drain(..) {
    match ev {
        GXEvent::Updated(id, v) if id == e.id =&gt; println!("2 + 2 = {v}"),
        GXEvent::Env(e) =&gt; env = e
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refs-and-trefs-depending-on-graphix-variables"><a class="header" href="#refs-and-trefs-depending-on-graphix-variables">Refs and TRefs, Depending on Graphix Variables</a></h2>
<p>If you want to be notified when a variable in Graphix updates you can register a
<a href="https://docs.rs/graphix-rt/latest/graphix_rt/struct.Ref.html"><code>Ref</code></a>, or a
<a href="https://docs.rs/graphix-rt/latest/graphix_rt/struct.TRef.html"><code>TRef</code></a> if you
have a corresponding rust type that implements
<a href="https://docs.rs/netidx-value/latest/netidx_value/trait.FromValue.html"><code>FromValue</code></a>.
There are two ways to get a ref, by id and by name. By id is probably the most
common, because
<a href="https://docs.rs/graphix-compiler/latest/graphix_compiler/struct.BindId.html"><code>BindId</code></a>
will appear in any data structure that has a value passed by ref (e.g. &amp;v),
which should be common for large structures that don't change often.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// assume we got id from a data structure and it's type is &amp;i64
let mut r = handle.compile_ref(id)

// if the variable r is bound to has a value right now it will be in last
if let Some(v) = &amp;r.last {
    println!("current value: {v}")
}

// now we will get an update whenever the variable updates
let mut batch = rx.recv().await.ok_or_else(|| anyhow!("the runtime is dead"))?;
for ev in batch.drain(..) {
    match ev {
        GXEvent::Updated(id, v) =&gt; {
            if let Some(v) = r.update(id, &amp;v) {
                println!("current value {v}")
            }
        },
        GXEvent::Env(_) =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can also set refs, which is exactly the same thing as the connect operator
<code>&lt;-</code>, and does what you expect it should do.</p>
<h3 id="ref-by-name"><a class="header" href="#ref-by-name">Ref By Name</a></h3>
<p>We can also reference a variable by name,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut r = handle.compile_ref_by_name(&amp;env, &amp;Scope::root(), &amp;ModPath::from(["foo"])).await?;

// the rest of the code is exactly the same
<span class="boring">}</span></code></pre></pre>
<h2 id="calling-graphix-functions"><a class="header" href="#calling-graphix-functions">Calling Graphix Functions</a></h2>
<p>Now lets register a call site, call a Graphix function, and get it's result. We
do this by calling
<a href="https://docs.rs/graphix-rt/latest/graphix_rt/struct.GXHandle.html#method.compile_callable_by_name"><code>compile_callable_by_name</code></a>
on the handle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut f = handle.compile_callable_by_name(&amp;env, &amp;Scope::root(), &amp;ModPath::from(["sum"])).await?;
f.call(ValArray::from_iter_exact([Value::from(1), Value::from(2), Value::from(3)])).await?;

// now we must update f to drive both late binding, and get our return value
// we need a loop this time because there will be multiple updates
loop {
    let mut batch = rx.recv().ok_or_else(|| anyhow!("the runtime is dead"))?;
    for ev in batch.drain(..) {
        match ev {
            GXEvent::Updated(id, v) =&gt; {
                if let Some(v) = f.update(&amp;v).await {
                    println!("sum returned {v}")
                }
            }
            GXEvent::Env(e) =&gt; env = e,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="calling-functions-by-lambdaid"><a class="header" href="#calling-functions-by-lambdaid">Calling Functions by LambdaId</a></h3>
<p>The above case applies when we only know the name of the function we want to
call, which is less common than you might imagine. If the function was passed in
to us, for example we evaluated an expression that returned a function, then
it's actually easier to deal with because we don't have to handle late binding.
In this case we can call
<a href="embedding/%5B%60compile_callable_by_name%60%5D(https://docs.rs/graphix-rt/latest/graphix_rt/struct.GXHandle.html#method.compile_callable)"><code>compile_callable</code></a>
on the handle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// id is the LambdaId of the function as a Value. Lets assume it's sum
let f = handle.compile_callable(id).await?;
f.call(ValArray::from_iter_exact([Value::from(1), Value::from(41)])).await?;

// now wait for the value
let mut batch = rx.recv().ok_or_else(|| anyhow!("the runtime is dead"))?;
for ev in batch.drain(..) {
    match ev {
        GXEvent::Updated(id, v) =&gt; {
            if let Some(v) = f.update(&amp;v) {
                println!("sum returned {v}")
            }
        }
        GxEvent::Env(e) =&gt; env = e,
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/graphix-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
