<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Select - The Graphix Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Select lets us create a graph node with multiple possible output paths that
will choose one path for each value based on a set of conditions. Kind of like,</p>
<pre><code>                     ┌─────────────────────&gt; if foo &gt; 0 =&gt; ...
                     │
                     │
ref(foo) ──&gt; select ─┼─────────────────────&gt; if foo &lt; 0 =&gt; ...
                     │
                     │
                     └─────────────────────&gt; otherwise =&gt; ...
</code></pre>
<p>is written as</p>
<pre><code class="language-graphix">select foo {
  n if n &gt; 0 =&gt; ...,
  n if n &lt; 0 =&gt; ...,
  n =&gt; ...
}
</code></pre>
<p>select takes an expression as an argument and then evaluates one or more "arms".
Each arm consists of an optional type predicate, a destructuring pattern, and an
optional guard clause. If the type predicate matches, the pattern matches, and
the guard evaluates to true then the arm is "selected". Only one arm may be
selected at a time, the arms are evaluated in lexical order, and first arm to be
selected is chosen as the one and only selected arm.</p>
<p>The code on the right side of the selected arm is the only code that is
evaluated by select, all other code is "asleep", it will not be evaluated
until it is selected (and if it has netidx subscriptions or published values
they will be unsubscribed and unpublished until it is selected again).</p>
<h2 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h2>
<p>Consider we want to select from a value of type <code>[Array&lt;i64&gt;, i64, null]</code>,</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This program will print 42, 15, 7 and then wait. The compiler will check that
you have handled all the possible cases. If we remove the null case from this
select we will get a compile error.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    missing match cases type mismatch [i64, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>If you read this carefully you can see that the compiler is building up a set of
types that we did match, and checking that it contains the argument type. This
goes both ways, a match case that could never match is also an error.</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  f64 as n =&gt; cast&lt;i64&gt;(n)?,
  null as _ =&gt; 42
}
</code></pre>
<p>Here we've added an <code>f64</code> match case, but the argument type can never contain an
<code>f64</code> so we will get a compile error.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern f64 will never match null, unused match cases
</code></pre>
<p>The diagnostic message gives you an insight into the compiler's thinking. What
it is saying is that, by the time it's gotten to looking at the <code>f64</code> pattern,
the only type left in the argument that hasn't already been matched is <code>null</code>,
and since <code>f64</code> doesn't unify with <code>null</code> it is sure this pattern can never
match.</p>
<p>Guarded patterns can always not match because of the guard, so they do not
subtract from the argument type set. You are required to match without a guard
at some point. No analysis is done to determine if your guard covers the entire
range of a type.</p>
<pre><code class="language-graphix">let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n if n &gt; 10 =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This will fail with a missing match case because the <code>i64</code> pattern is guarded
and no unguarded pattern exists that matches <code>i64</code>.</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    missing match cases type mismatch [null, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>This is the same error you would get if you omitted the <code>i64</code> match case
entirely.</p>
<h2 id="matching-structure"><a class="header" href="#matching-structure">Matching Structure</a></h2>
<p>The type predicate is optional in a pattern, and the more commonly used pattern
is structural. Graphix supports several kinds of structural matching,</p>
<ul>
<li>array slices</li>
<li>tuples</li>
<li>structs</li>
<li>variants</li>
<li>literals, ignore</li>
</ul>
<p>NB: In most contexts you can match the entire value as well as parts of it's
structure by adding a <code>v@</code> pattern before the pattern. You will see this in many
of the examples.</p>
<h3 id="slice-patterns"><a class="header" href="#slice-patterns">Slice Patterns</a></h3>
<p>Suppose we want to classify arrays that have at least two elements vs arrays
that don't, and we want to return a variant with a triple of the first two
elements and the rest of the array or `Short with the whole array.</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4];
a &lt;- [1];
a &lt;- [5, 6];
select a {
  [x, y, tl..] =&gt; `Ok((x, y, tl)),
  a =&gt; `Short(a)
}
</code></pre>
<p>This program will print,</p>
<pre><code>$ graphix test.gx
`Ok((1, 2, [3, 4]))
`Short([1])
`Ok((5, 6, []))
</code></pre>
<p>The following kinds of slice patterns are supported,</p>
<ul>
<li>
<p>whole slice, with binds, or literals, e.g. <code>[1, x, 2, y]</code> matches a 4 element
array and binds it's 2nd and 4th element to <code>x</code> and <code>y</code> respectively.</p>
</li>
<li>
<p>head pattern, like the above program, e.g. <code>[(x, y), ..]</code> matches the first
pair in an array of pairs and ignores the rest of the array, binding the pair
elements to <code>x</code> and <code>y</code>. You can also name the remainder, as we saw, e.g.
<code>[(x, y), tl..]</code> does the same thing, but binds the rest of the array to <code>tl</code></p>
</li>
<li>
<p>tail pattern, just like the head pattern, but for the end of the array. e.g.
<code>[hd.., {foo, bar}]</code> matches the last element of an array of structs with
fields <code>foo</code> and <code>bar</code>, binding <code>hd</code> to the array minus the last element, and
<code>foo</code> to field foo and <code>bar</code> to field bar.</p>
</li>
</ul>
<p>Structure patterns (all of the different types) can be nested to any depth.</p>
<h3 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple Patterns</a></h3>
<p>Tuple patterns allow you to match tuples. Compared to slice patterns they are
fairly simple. You must specify every field of the tuple, you can choose to bind
it, or ignore it with <code>_</code>. e.g.</p>
<p><code>("I", "am", "a", "happy", "tuple", w, _, "patterns")</code></p>
<h3 id="struct-patterns"><a class="header" href="#struct-patterns">Struct Patterns</a></h3>
<p>Struct patterns, like tuple patterns, are pretty simple.</p>
<ul>
<li><code>{ x, y }</code> if you like the field names then there is no need to change them</li>
<li><code>{ x: x_coord, y: y_coord }</code> but if you need to use a different name you can</li>
<li><code>{ x, .. }</code> you don't have to write every field</li>
</ul>
<p>Consider</p>
<pre><code class="language-graphix">let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  {x, y: _} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  {y, x: _} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>does some 2d bounds checking, and will output</p>
<pre><code>$ graphix test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>You might be tempted to replace <code>y: _</code> with <code>..</code> as it would be shorter.
Unfortunately this will confuse the type checker, because the Graphix type system
is structural saying <code>{x, ..}</code> without any other information could match ANY
struct with a field called <code>x</code>. This is currently too much for the type checker
to handle,</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern {x: '_1040} will never match {x: i64, y: i64}, unused match cases
</code></pre>
<p>The error is slightly confusing at first, until you understand that since we
don't know the type of <code>{x, ..}</code> we don't think it will match the argument type,
and therefore the match case is unused. This actually saves us a lot of trouble
here, because the last match is exhaustive, if we didn't check for unused match
cases this program would compile, but it wouldn't work. You can easily fix this
by naming the type, and for larger structs it's often worth it if you only need
a few fields.</p>
<pre><code class="language-graphix">type T = {x: i64, y: i64};
let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  T as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  T as {y, ..} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>Here since we've included the type pattern <code>T</code> in our partial patterns the
program compiles and runs.</p>
<pre><code>$ graphix test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>Note that we never told the compiler that <code>a</code> is of
type <code>T</code>. In fact <code>T</code> is just an alias for <code>{x: i64, y: i64}</code> which is the type
of <code>a</code>. We could in fact write our patterns without the alias,</p>
<p><code>{x: i64, y: i64} as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall</code></p>
<p>The type alias just makes the code less verbose without changing the semantics.</p>
<h3 id="variant-patterns"><a class="header" href="#variant-patterns">Variant Patterns</a></h3>
<p>Variant patterns match variants. Consider,</p>
<pre><code class="language-graphix">let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]"
}
</code></pre>
<p>produces</p>
<pre><code>$ graphix test.gx
"it's bare, no argument"
"it has an arg 42"
"it's big `MoreArg(\"hello world\", 42) with args \"hello world\" and 42"
</code></pre>
<p>Variant patterns enforce the same kinds of match case checking as all the other pattern types</p>
<pre><code class="language-graphix">let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]",
  `Wrong =&gt; "this won't compile"
}
</code></pre>
<p>yields</p>
<pre><code>$ graphix test.gx
Error: in file "test.gx"

Caused by:
    pattern `Wrong will never match [`Arg(i64), `MoreArg(string, i64)], unused match cases
</code></pre>
<h3 id="literals-ignore"><a class="header" href="#literals-ignore">Literals, Ignore</a></h3>
<p>You can match literals as well as bind variables, as you may have noticed, and
the special pattern <code>_</code> means match anything and don't bind it to a variable.</p>
<h3 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h3>
<p>A significant missing feature from patterns vs other languages is support for
multiple alternative patterns in one arm. I plan to add this at some point.</p>
<h2 id="select-and-connect"><a class="header" href="#select-and-connect">Select and Connect</a></h2>
<p>Using select and connect together is one way to iterate in Graphix. Consider,</p>
<pre><code class="language-graphix">let a = [1, 2, 3, 4, 5];
let len = 0;
select a {
  [x, tl..] =&gt; {
    len &lt;- len + 1;
    a &lt;- tl
  },
  _ =&gt; len
}
</code></pre>
<p>produces</p>
<pre><code>$ graphix test.gx
5
</code></pre>
<p>This is not normally how we would get the length of an array in Graphix, or even
how we would do something with every element of an array (see <code>array::map</code> and
<code>array::fold</code>), however it illustrates the power of select and connect together.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../core/use.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../core/error.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../core/use.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../core/error.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/graphix-highlight.js"></script>



    </div>
    </body>
</html>
