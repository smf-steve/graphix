type WatchEventKind = [
   `Create,
   `Modify,
   `Delete,
   `Rename
]

/// watch the file or directory for change events, ignoring any kind of
/// event not in the set, using the most efficient OS specific mechanism available
/// (which in the worst case will be polling). return the name and event if the file changed,
/// or if the name changed. Return an error if the watch could not be established, continue
/// trying to establish the watch with backoff but do not return additional identical errors.
let watch = |
    #interest:Array<WatchEventKind> = [`Modify, `Create],
    name:string
| -> Result<string, `WatchError(string)>;

type WatchDirEvent = [
   `Established,
   `Created(string),
   `Modified(string),
   `Deleted(string),
   `Renamed(string, string)
];

/// watch the specified file, directory, or directory tree for changes matching interest.
/// Return an error if the watch can't be established, keep trying with backoff, but don't
/// return additional identical errors. Return an `Established event when the watch is
/// successfully established, followed by any events that occur.
let watch_full = |
    #interest:Array<WatchEventKind> = [`Modify, `Create],
    #recursive:bool,
    name:string
| -> Result<WatchDirEvent, `WatchError(string)>;

type FileType = [
    `Dir,
    `File,
    `Symlink
];

type DirEnt = { name: string, file_type: FileType, path: string };

/// Read the directory specified by name and return an array of DirEnt
/// records describing it's contents. Reread the directory contents each
/// time name updates even if it did not change.
let readdir = |name: string| -> Result<Array<DirEnt>, `IOError(string)>;

/// copy the source file to dest. perform the copy again every time source updates
/// even if it is the same, or every time the dest updates if it is different.
/// return the dest, or an IOError.
let copy = |#source:string, #dest:string| -> Result<string, `IOError(string)>;

/// move the source to dest, removing the existing dest if it already exists.
/// perform the move each time source updates, even if it is the same, or dest
/// updates if it is different. return the dest, or an IOError.
let rename = |#source:string, #dest:string| -> Result<string, `IOError(string)>;

/// create the specified directory
let create_dir = |name:string| -> Result<string, `IOError(string)>;

/// create the specified directory and all it's parents.
let create_dir_all = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified file. perform the remove again each time name updates.
/// return the name of the removed file or an IOError.
let remove_file = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified empty directory. perform the remove again each time name updates.
/// return the name of the removed directory, or an IOError.
let remove_dir = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified directory and all it's contents. perform the remove again
/// each time name updates. Return the removed directory, or an IOError.
let remove_dir_all = |name:string| -> Result<string, `IOError(string)>;

/// if the specified path exists, return it, otherwise return an error. check
/// each time name updates.
let exists = |name:string| -> Result<string, `IOError>;

/// return the type of the specified file, or null if it does not exist. check each time
/// name updates.
let kind = |name:string| -> Option<FileType>;

/// read the entire file to a string. Reread the file contents each time name updates
/// even if it did not change.  Return an `IOError if the read failed, or if the
/// contents of the file are not valid UTF8. The file will be closed immediately after
/// the write completes.
let read_all = |name: string| -> Result<string, `IOError(string)>;

/// write the specified string to a file. If the file already exists truncate
/// and rewrite it. Truncate and rewrite the file whenever value updates.
/// Return an `IOError if the write fails. The file will be closed immediately
/// after the write completes.
let write_all = |#name: string, value: string| -> Result<null, `IOError(string)>;

/// read the entire file to a bytes. Reread the contents each time name updates,
/// even if it did not change. Return an `IOError if the read failed.
/// the file will be closed immediately after the read is complete.
let read_all_bin = |name: string| -> Result<bytes, `IOError(string)>;

/// write the specified bytes to a file. If the file already exists
/// truncate and rewrite it with the contents of buf. Return an `IOError if
/// the write fails. The file will be closed immediately after the write is complete.
let write_all_bin = |#name: string, buf: bytes| -> Result<null, `IOError(string)>;

type OpenOptions = {
    path: string,
    read: bool,
    write: bool,
    create: bool,
    append: bool,
};

type FileCmd = [
    `Open(OpenOptions),
    `Close,
    `Sync,
    `SetLen(u64),
    `Metadata,
    `Seek([Relative(i64), `Start(u64), `End(i64)]),
    `Lock,
    `TryLock,
    `LockShared,
    `TryLockShared,
    `Unlock,
    `Read(i64),
    `Write(bytes)
];

type FileResult = [
    `Open(Result<null, `IOError(string)>),
    `Clone(Result<null, `IOError(string)>),
    `Sync(Result<null, `IOError(string)>),
    `SetLen(Result<null, `IOError(string)>),
    `Metadata(Result<Metadata, `IOError(string)>),
    `Seek(Result<u64, `IOError(string)>),
    `Lock(Result<null, `IOError(string)>),
    `TryLock(Result<null, `IOError(string)>),
    `LockShared(Result<null, `IOError(string)>),
    `TryLockShared(Result<null, `IOError(string)>),
    `Read(Result<bytes, `IOError(string)>),
    `Write(Result<null, `IOError(string)>)
];

/// Execute commands on a file, return the corresponding result for the
/// operation performed.
///
/// sending an Open command when a file is already open will close the current
/// file and open the new one. The operation will return one null on success.
/// If the close fails the failure will not be reported but will be logged.
pub let file = |cmd| 'fs_file
