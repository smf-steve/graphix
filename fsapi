type WatchEventKind = [
   `Create,
   `Modify,
   `Delete,
   `Rename
]

/// watch the file or directory for change events, ignoring any kind of
/// event not in the set, using the most efficient OS specific mechanism available
/// (which in the worst case will be polling). return the name and event if the file changed,
/// or if the name changed. Return an error if the watch could not be established, continue
/// trying to establish the watch with backoff but do not return additional identical errors.
let watch = |
    #interest:Array<WatchEventKind> = [`Modify, `Create],
    name:string
| -> Result<string, `WatchError(string)>;

type WatchDirEvent = [
   `Established,
   `Created(string),
   `Modified(string),
   `Deleted(string),
   `Renamed(string, string)
];

/// watch the specified file, directory, or directory tree for changes matching interest.
/// Return an error if the watch can't be established, keep trying with backoff, but don't
/// return additional identical errors. Return an `Established event when the watch is
/// successfully established, followed by any events that occur.
let watch_full = |
    #interest:Array<WatchEventKind> = [`Modify, `Create],
    #recursive:bool,
    name:string
| -> Result<WatchDirEvent, `WatchError(string)>;

type FileType = [
    `Dir,
    `File,
    `Symlink
];

type DirEnt = { name: string, file_type: FileType, path: string };

/// Read the directory specified by name and return an array of DirEnt
/// records describing it's contents. Reread the directory contents each
/// time name updates even if it did not change.
let readdir = |name: string| -> Result<Array<DirEnt>, `IOError(string)>;

/// copy the source file to dest. perform the copy again every time source updates
/// even if it is the same, or every time the dest updates if it is different.
/// return the dest, or an IOError.
let copy = |#source:string, #dest:string| -> Result<string, `IOError(string)>;

/// move the source to dest, removing the existing dest if it already exists.
/// perform the move each time source updates, even if it is the same, or dest
/// updates if it is different. return the dest, or an IOError.
let rename = |#source:string, #dest:string| -> Result<string, `IOError(string)>;

/// create the specified directory
let create_dir = |name:string| -> Result<string, `IOError(string)>;

/// create the specified directory and all it's parents.
let create_dir_all = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified file. perform the remove again each time name updates.
/// return the name of the removed file or an IOError.
let remove_file = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified empty directory. perform the remove again each time name updates.
/// return the name of the removed directory, or an IOError.
let remove_dir = |name:string| -> Result<string, `IOError(string)>;

/// remove the specified directory and all it's contents. perform the remove again
/// each time name updates. Return the removed directory, or an IOError.
let remove_dir_all = |name:string| -> Result<string, `IOError(string)>;

/// if the specified path exists, return it, otherwise return an error. check
/// each time name updates.
let exists = |name:string| -> Result<string, `IOError>;

/// return the type of the specified file, or null if it does not exist. check each time
/// name updates.
let kind = |name:string| -> Option<FileType>;

/// read the entire file to a string. Reread the file contents each time name updates
/// even if it did not change.  Return an `IOError if the read failed, or if the
/// contents of the file are not valid UTF8. The file will be closed immediately after
/// the write completes.
let read_all = |name: string| -> Result<string, `IOError(string)>;

/// write the specified string to a file. If the file already exists truncate
/// and rewrite it. Truncate and rewrite the file whenever value updates.
/// Return an `IOError if the write fails. The file will be closed immediately
/// after the write completes.
let write_all = |#name: string, value: string| -> Result<null, `IOError(string)>;

/// read the entire file to a bytes. Reread the contents each time name updates,
/// even if it did not change. Return an `IOError if the read failed.
/// the file will be closed immediately after the read is complete.
let read_all_bin = |name: string| -> Result<bytes, `IOError(string)>;

/// write the specified bytes to a file. If the file already exists
/// truncate and rewrite it with the contents of buf. Return an `IOError if
/// the write fails. The file will be closed immediately after the write is complete.
let write_all_bin = |#name: string, buf: bytes| -> Result<null, `IOError(string)>;

type Seek = [
    `Beginning(u64),
    `End(u64),
    `Relative(i64)
];

type OpenReadOpts = {
   close_on_error: bool,
   flags: [] // windows sharing flags, platform specific flags
}

type ReadCommand = [
    `Open(string),
    `OpenOpts(string, OpenReadOpts)
    `Seek(Seek),
    `Read(i64),
    `Close
];

/// Execute the read command stream, either as a single command, or as a batch. If batch
/// execution, then if any command in the batch fails, subsequent commands will not execute.
/// commands that do not cause a read return either nothing, or an error. The read command
/// returns a bytes.
///
/// e.g. read(#command:[`Open("foo"), `Seek(End(u64:100)), `Read(50), `Read(50), `Close])
/// will open "foo", read the last 100 bytes in two chunks of 50, and then close the file.
/// assuming no error, this will cause read to update twice with a 50 byte chunk each time.
///
/// e.g. you can also feed commands singly
/// let command = `Open("foo");
/// command <- array::iter([`Seek(End(u64:100)), `Read(50), `Read(50), `Close]);
/// read(#command)
///
/// will result in exactly the same behavior if no errors occur. However in the case of an
/// error each command will execute whether it makes sense or not. However it can be reasonable
/// to work this way.
///
/// e.g.
/// let command: [ReadCommand, Array<ReadCommand>] = [`Open("foo"), `Seek(`Beginning(u64:100))];
/// command <- `Read(50);
/// let b = read(#command)?;
/// select b {
///     bytes as b if len(b) > 0 => command <- b ~ `Read(50),
///     _ => command <- `Close
/// }
///
/// read the file 50 bytes at a time into b and close it once EOF is reached.
///
/// This is a low level function which allows you total control over files, with the
/// cost of having to deal with the complexity of files.
let read = |#command:[ReadCommand, Array<ReadCommand>]|
    -> Result<bytes, `ReadError(ReadCommand, string)>;

type OpenWriteOpts = {
   close_on_error: bool,
   flags: [] // windows sharing flags, platform specific flags
}

type WriteCommand = [
    `Open(string),
    `OpenOpts(string, OpenWriteOpts),
    `Seek(Seek),
    `Write(bytes),
    `Flush,
    `Close
];

/// Execute the write command stream, either as a single command, or as a batch. If batch
/// execution, then if any command in the batch fails, subsequent commands will not execute.
/// commands other than write return either nothing or an error. The write command returns
/// either null on completion, or an error.
let write = |#command:[WriteCommand, Array<WriteCommand>]|
    -> Result<null, `WriteError(WriteCommand, string)>;
