// The type of file system events you are interested in.
// The short names, e.g. `Access mean ANY kind of access event.
// The longer names e.g. `AccessOpen mean a more specific subset
// of the short named class event. There are sometimes multiple
// levels of this. For example `Modify expresses interest in
// any modification, `ModifyRename expresses interest in any
// kind of rename operation, and `ModifyRenameTo expresses interest
// only on rename to.
type Interest = [
    `Established,
    `Any,
    `Access,
    `AccessOpen,
    `AccessClose,
    `AccessRead,
    `AccessOther,
    `Create,
    `CreateFile,
    `CreateFolder,
    `CreateOther,
    `Modify,
    `ModifyData,
    `ModifyDataSize,
    `ModifyDataContent,
    `ModifyDataOther,
    `ModifyMetadata,
    `ModifyMetadataAccessTime,
    `ModifyMetadataWriteTime,
    `ModifyMetadataPermissions,
    `ModifyMetadataOwnership,
    `ModifyMetadataExtended,
    `ModifyMetadataOther,
    `ModifyRename,
    `ModifyRenameTo,
    `ModifyRenameFrom,
    `ModifyRenameBoth,
    `ModifyRenameOther,
    `ModifyOther,
    `Delete,
    `DeleteFile,
    `DeleteFolder,
    `DeleteOther,
    `Other
];

type WatchEvent = {
    paths: Array<string>,
    event: Interest
};

/// - poll_interval: how often to poll a batch of watched files. (default 1 second)
/// the minimum allowed poll interval is 100ms.
///
/// - poll_batch_size: how many watched files are in each poll batch (default 100)
/// if poll_batch_size is set to 0 then polling will be DISABLED globally. If you
/// disable polling some of the stranger corner cases, such as your parent directory
/// being renamed, will not be handled.
///
/// inotify, fsevents, etc have many problems, and so even though we use them
/// we must also poll to ensure correct semantics. You can consider the worst
/// case time you will find out about file creation, deletion, rename to be,
/// (N / poll_batch_size) * poll_interval. Where N is the number of files you
/// are watching globally.
let set_global_watch_parameters = |
    #poll_interval = null,
    #poll_batch_size = null
| 'fs_set_global_watch_parameters;

/// Watch the specified path for events matching #interest. Return the canonical
/// path of the filesystem object involved in the event, or an error if the
/// watch could not be established. watch updates when,
/// - path updates
/// - an event occurs that matches interest
/// - an error occurs when trying to establish the watch
///
/// If path is a directory the watch will report events about immediate children.
/// If the watch could not be established establishement will be retried every
/// time path updates
///
/// Filesystem watches are a limited operating system resource, like file
/// descriptors, or handles.
pub let watch = |#interest = [`Create, `Modify, `Delete], path| 'fs_watch;

/// Watch the specified path for events matching #interest. Return the full event
/// describing what happened, or an error if the watch could not be established.
/// watch_full updates when
/// - path updates
/// - an event occurs that matches interest
/// - an error occurs when trying to establish the watch
///
/// If path is a directory the watch will report events about immediate children.
/// If the watch could not be established establishement will be retried every
/// time path updates
///
/// Filesystem watches are a limited operating system resource, like file
/// descriptors, or handles.
pub let watch_full = |#interest = [`Create, `Modify, `Delete], path| 'fs_watch_full;

/// Read the specified file into memory as a utf8 string and return it, or an
/// error if,
/// - path is not a file
/// - path is not valid utf8
/// - an OS specific error occurs while trying to read path
///
/// The file will be read again each time path updates, even if path did not change.
/// Reads will be returned in the same order they are initiated, even if they complete
/// out of order. For example, if we read_all on path0 and path1, read_all will always
/// return the result for path0 first. If the result for path0 is not ready then read_all
/// will wait for it even if the result for path1 has already been delivered.
pub let read_all = |path| 'fs_read_all;

/// Read the specified file into memory as a bytes and return it, or an
/// error if,
/// - path is not a file
/// - an OS specific error occurs while trying to read path
///
/// The file will be read again each time path updates, even if path did not change.
/// Reads will be returned in the same order they are initiated, even if they complete
/// out of order. For example, if we read_all_bin on path0 and path1, read_all_bin will always
/// return the result for path0 first. If the result for path0 is not ready then read_all_bin
/// will wait for it even if the result for path1 has already been delivered.
pub let read_all_bin = |path| 'fs_read_all_bin;

/// Write data to path. If path does not exist it will be created. If path exists it
/// will be truncated and it's contents will be replaced with data.
///
/// A write will occur whenever either path or data updates, even if they did not change.
/// If multiple writes are in flight at once their completion order in the file
/// system is not specified, but the results will always be reported in the order
/// they were queued. For example if "hello world" is queued to be written to
/// "foo.txt" and "bar.txt", there is no guarantee about when foo.txt and bar.txt will
/// appear in the file system. However the first result will always be the result of writing to
/// "foo.txt" and the second result will always be the result of writing to "bar.txt", and when
/// the "bar.txt" result is reported it is guaranteed that both writes have been handed to the OS.
pub let write_all = |#path, data| 'fs_write_all;

/// Write data to path. If path does not exist it will be created. If path exists it
/// will be truncated and it's contents will be replaced with data.
///
/// A write will occur whenever either path or data updates, even if they did not change.
/// If multiple writes are in flight at once their completion order in the file
/// system is not specified, but the results will always be reported in the order
/// they were queued. For example if "hello world" is queued to be written to
/// "foo.txt" and "bar.txt", there is no guarantee about when foo.txt and bar.txt will
/// appear in the file system. However the first result will always be the result of writing to
/// "foo.txt" and the second result will always be the result of writing to "bar.txt", and when
/// the "bar.txt" result is reported it is guaranteed that both writes have been handed to the OS.
pub let write_all_bin = |#path, data| 'fs_write_all_bin;
